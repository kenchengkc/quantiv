"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/expected-move/route";
exports.ids = ["app/api/expected-move/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:crypto");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexpected-move%2Froute&page=%2Fapi%2Fexpected-move%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexpected-move%2Froute.ts&appDir=%2FUsers%2Fken%2FDesktop%2Fquantiv%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fken%2FDesktop%2Fquantiv&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexpected-move%2Froute&page=%2Fapi%2Fexpected-move%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexpected-move%2Froute.ts&appDir=%2FUsers%2Fken%2FDesktop%2Fquantiv%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fken%2FDesktop%2Fquantiv&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_ken_Desktop_quantiv_app_api_expected_move_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/expected-move/route.ts */ \"(rsc)/./app/api/expected-move/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/expected-move/route\",\n        pathname: \"/api/expected-move\",\n        filename: \"route\",\n        bundlePath: \"app/api/expected-move/route\"\n    },\n    resolvedPagePath: \"/Users/ken/Desktop/quantiv/app/api/expected-move/route.ts\",\n    nextConfigOutput,\n    userland: _Users_ken_Desktop_quantiv_app_api_expected_move_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/expected-move/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZleHBlY3RlZC1tb3ZlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZleHBlY3RlZC1tb3ZlJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZXhwZWN0ZWQtbW92ZSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmtlbiUyRkRlc2t0b3AlMkZxdWFudGl2JTJGYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj0lMkZVc2VycyUyRmtlbiUyRkRlc2t0b3AlMkZxdWFudGl2JmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQWlFO0FBQ3pFO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDdUg7O0FBRXZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbnRpdi8/N2QxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMva2VuL0Rlc2t0b3AvcXVhbnRpdi9hcHAvYXBpL2V4cGVjdGVkLW1vdmUvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL2V4cGVjdGVkLW1vdmUvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9leHBlY3RlZC1tb3ZlXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9leHBlY3RlZC1tb3ZlL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2tlbi9EZXNrdG9wL3F1YW50aXYvYXBwL2FwaS9leHBlY3RlZC1tb3ZlL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS9leHBlY3RlZC1tb3ZlL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexpected-move%2Froute&page=%2Fapi%2Fexpected-move%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexpected-move%2Froute.ts&appDir=%2FUsers%2Fken%2FDesktop%2Fquantiv%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fken%2FDesktop%2Fquantiv&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/expected-move/route.ts":
/*!****************************************!*\
  !*** ./app/api/expected-move/route.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   OPTIONS: () => (/* binding */ OPTIONS)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/schemas */ \"(rsc)/./lib/schemas.ts\");\n/* harmony import */ var _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/cache/lru */ \"(rsc)/./lib/cache/lru.ts\");\n/* harmony import */ var _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/cache/redis */ \"(rsc)/./lib/cache/redis.ts\");\n/* harmony import */ var _lib_services_liveDataService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/services/liveDataService */ \"(rsc)/./lib/services/liveDataService.ts\");\n/* harmony import */ var _lib_services_expectedMove__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/services/expectedMove */ \"(rsc)/./lib/services/expectedMove.ts\");\n/* harmony import */ var _lib_services_ivStats__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/services/ivStats */ \"(rsc)/./lib/services/ivStats.ts\");\n/**\n * /api/expected-move - Expected move calculations endpoint\n * Returns expected move data using straddle and IV methods with confidence assessment\n */ \n\n\n\n\n\n\n/**\n * Mock options data provider (shared logic with /api/options)\n * In production, this would be extracted to a shared provider service\n */ class OptionsProvider {\n    static async getChain(symbol, expiry) {\n        // Simulate API delay\n        await new Promise((resolve)=>setTimeout(resolve, 80));\n        const spot = 150.00 + Math.random() * 50;\n        const selectedExpiry = expiry || \"2024-02-16\";\n        const expiryDate = new Date(selectedExpiry);\n        const daysToExpiry = Math.max(1, Math.ceil((expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)));\n        // Generate strikes around spot price\n        const strikes = [];\n        const baseStrike = Math.round(spot / 5) * 5;\n        for(let i = -10; i <= 10; i++){\n            strikes.push(baseStrike + i * 5);\n        }\n        // Generate mock options data with realistic pricing\n        const calls = strikes.map((strike)=>{\n            const intrinsic = Math.max(0, spot - strike);\n            const timeValue = Math.random() * 3 + 0.5;\n            const mid = intrinsic + timeValue;\n            const spread = Math.max(0.01, mid * 0.04); // 4% spread\n            return {\n                strike,\n                mid,\n                bid: Math.max(0.01, mid - spread / 2),\n                ask: mid + spread / 2,\n                iv: 0.20 + Math.random() * 0.30,\n                volume: Math.floor(Math.random() * 1000),\n                openInterest: Math.floor(Math.random() * 5000)\n            };\n        });\n        const puts = strikes.map((strike)=>{\n            const intrinsic = Math.max(0, strike - spot);\n            const timeValue = Math.random() * 3 + 0.5;\n            const mid = intrinsic + timeValue;\n            const spread = Math.max(0.01, mid * 0.04);\n            return {\n                strike,\n                mid,\n                bid: Math.max(0.01, mid - spread / 2),\n                ask: mid + spread / 2,\n                iv: 0.20 + Math.random() * 0.30,\n                volume: Math.floor(Math.random() * 1000),\n                openInterest: Math.floor(Math.random() * 5000)\n            };\n        });\n        return {\n            spot,\n            expiryDate: selectedExpiry,\n            daysToExpiry,\n            strikes,\n            calls,\n            puts\n        };\n    }\n}\n/**\n * GET /api/expected-move?symbol=AAPL&expiry=2024-01-19\n */ async function GET(request) {\n    const startTime = Date.now();\n    try {\n        // Parse and validate query parameters\n        const url = new URL(request.url);\n        const params = {\n            symbol: url.searchParams.get(\"symbol\"),\n            expiry: url.searchParams.get(\"expiry\") || undefined\n        };\n        const validation = (0,_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.validateRequest)(_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.ExpectedMoveRequestSchema, params);\n        if (!validation.success) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json((0,_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.createApiResponse)(undefined, \"Invalid request parameters\", validation.details?.join(\", \")), {\n                status: 400\n            });\n        }\n        const { symbol, expiry } = validation.data;\n        // Generate cache key for expected move\n        const emCacheKey = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheKeys.expectedMove(symbol, expiry || \"default\");\n        // Try L1 cache first\n        let expectedMoveData = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.expectedMove.get(emCacheKey);\n        let cacheHit = \"l1\";\n        if (!expectedMoveData) {\n            // Try L2 (Redis) cache\n            const redisKey = _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.Keys.expectedMoveSnapshot(symbol, expiry || \"default\");\n            expectedMoveData = await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.RedisCache.getJson(redisKey);\n            cacheHit = expectedMoveData ? \"l2\" : \"miss\";\n            if (!expectedMoveData) {\n                // Try to fetch live expected move data first\n                let liveExpectedMoveData = null;\n                if ((0,_lib_services_liveDataService__WEBPACK_IMPORTED_MODULE_4__.isLiveDataAvailable)()) {\n                    try {\n                        liveExpectedMoveData = await (0,_lib_services_liveDataService__WEBPACK_IMPORTED_MODULE_4__.fetchLiveExpectedMove)(symbol);\n                        console.log(`[expected-move-api] Live data ${liveExpectedMoveData ? \"found\" : \"not found\"} for ${symbol}`);\n                    } catch (error) {\n                        console.warn(`[expected-move-api] Live data fetch failed for ${symbol}:`, error);\n                    }\n                }\n                // If we have live data, use it\n                if (liveExpectedMoveData) {\n                    expectedMoveData = {\n                        symbol,\n                        summary: {\n                            daily: liveExpectedMoveData.summary.daily,\n                            weekly: liveExpectedMoveData.summary.weekly,\n                            monthly: liveExpectedMoveData.summary.monthly\n                        },\n                        straddle: {\n                            price: liveExpectedMoveData.straddle.price,\n                            move: liveExpectedMoveData.straddle.move,\n                            movePercent: liveExpectedMoveData.straddle.movePercent\n                        },\n                        iv: {\n                            rank: liveExpectedMoveData.iv.rank,\n                            percentile: liveExpectedMoveData.iv.percentile,\n                            current: liveExpectedMoveData.iv.current,\n                            high52Week: liveExpectedMoveData.iv.high52Week,\n                            low52Week: liveExpectedMoveData.iv.low52Week\n                        },\n                        confidence: \"high\",\n                        method: \"straddle\",\n                        timeToExpiry: liveExpectedMoveData.timeToExpiry,\n                        underlyingPrice: liveExpectedMoveData.underlyingPrice,\n                        impliedVolatility: liveExpectedMoveData.impliedVolatility\n                    };\n                    // Cache the live data\n                    _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.expectedMove.set(emCacheKey, expectedMoveData);\n                    await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.RedisCache.setJson(_lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.Keys.expectedMoveSnapshot(symbol, expiry || \"default\"), expectedMoveData, 300); // 5 min TTL for live data\n                    const response = (0,_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.createApiResponse)(expectedMoveData);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response);\n                }\n                // Cache miss - calculate expected move using mock data\n                // First, get options chain data\n                const chainCacheKey = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheKeys.optionsChain(symbol, expiry || \"default\");\n                let chainData = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.optionsChain.get(chainCacheKey);\n                if (!chainData) {\n                    // Try Redis for chain data\n                    const chainRedisKey = _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.Keys.optionsChain(symbol, expiry || \"default\");\n                    chainData = await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.RedisCache.getJson(chainRedisKey);\n                    if (!chainData) {\n                        // Fetch fresh chain data\n                        chainData = await OptionsProvider.getChain(symbol, expiry);\n                        // Cache chain data\n                        _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.optionsChain.set(chainCacheKey, chainData, 60 * 1000);\n                        await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.RedisCache.setJson(chainRedisKey, chainData, 300);\n                    } else {\n                        // Cache in L1\n                        _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.optionsChain.set(chainCacheKey, chainData, 60 * 1000);\n                    }\n                }\n                // Calculate expected move\n                const expectedMove = (0,_lib_services_expectedMove__WEBPACK_IMPORTED_MODULE_5__.computeExpectedMove)(chainData);\n                const confidence = (0,_lib_services_expectedMove__WEBPACK_IMPORTED_MODULE_5__.assessConfidence)(chainData, expectedMove.atm);\n                expectedMoveData = {\n                    ...expectedMove,\n                    confidence,\n                    timestamp: new Date().toISOString(),\n                    symbol: symbol\n                };\n                // Cache expected move in both layers\n                _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.expectedMove.set(emCacheKey, expectedMoveData, 90 * 1000); // 1.5 minutes L1\n                await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.QuantivCache.cacheExpectedMove(symbol, expiry || \"default\", expectedMoveData, 180); // 3 minutes L2\n                // Add to top movers if significant move\n                if (expectedMoveData?.straddle?.pct > 5.0) {\n                    await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.QuantivCache.addTopMover(symbol, expectedMoveData.straddle.pct);\n                }\n                cacheHit = \"miss\";\n            } else {\n                // Cache in L1 for next time\n                _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.expectedMove.set(emCacheKey, expectedMoveData, 90 * 1000);\n            }\n        }\n        // Get IV rank data (mock for now)\n        const ivCacheKey = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheKeys.ivSeries(symbol, 252); // 1 year of data\n        let ivStats = _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.ivSeries.get(ivCacheKey);\n        if (!ivStats) {\n            // Generate mock IV data and calculate stats\n            const ivHistory = (0,_lib_services_ivStats__WEBPACK_IMPORTED_MODULE_6__.createMockIVHistory)(252, 0.25); // 1 year\n            const currentIV = expectedMoveData?.atm?.iv || 0.25;\n            ivStats = (0,_lib_services_ivStats__WEBPACK_IMPORTED_MODULE_6__.calculateIVStats)(ivHistory, currentIV);\n            // Cache IV stats\n            _lib_cache_lru__WEBPACK_IMPORTED_MODULE_2__.CacheInstances.ivSeries.set(ivCacheKey, ivStats, 1800 * 1000); // 30 minutes\n            await _lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.RedisCache.setJson(_lib_cache_redis__WEBPACK_IMPORTED_MODULE_3__.Keys.ivSeries(symbol), ivStats, 1800); // 30 minutes\n        }\n        // Transform data to match ExpectedMoveCard component expectations\n        const spotPrice = expectedMoveData?.atm?.spot || 150;\n        const straddleMove = expectedMoveData?.straddle;\n        const response = (0,_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.createApiResponse)({\n            symbol: symbol,\n            spotPrice: spotPrice,\n            summary: {\n                daily: straddleMove ? {\n                    move: straddleMove.abs,\n                    percentage: straddleMove.pct,\n                    lower: spotPrice - straddleMove.abs,\n                    upper: spotPrice + straddleMove.abs\n                } : null,\n                weekly: straddleMove ? {\n                    move: straddleMove.abs * 2.65,\n                    percentage: straddleMove.pct * 2.65,\n                    lower: spotPrice - straddleMove.abs * 2.65,\n                    upper: spotPrice + straddleMove.abs * 2.65\n                } : null,\n                monthly: straddleMove ? {\n                    move: straddleMove.abs * 5.48,\n                    percentage: straddleMove.pct * 5.48,\n                    lower: spotPrice - straddleMove.abs * 5.48,\n                    upper: spotPrice + straddleMove.abs * 5.48\n                } : null\n            },\n            // Also include the raw data for other components that might need it\n            em: expectedMoveData,\n            ivRank: ivStats\n        });\n        const processingTime = Date.now() - startTime;\n        // Add performance headers\n        const headers = new Headers({\n            \"Content-Type\": \"application/json\",\n            \"Cache-Control\": \"public, s-maxage=90, stale-while-revalidate=300\",\n            \"X-Cache-Hit\": cacheHit,\n            \"X-Processing-Time\": `${processingTime}ms`,\n            \"X-Symbol\": symbol,\n            \"X-Expiry\": expectedMoveData?.atm?.expiry || \"default\"\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response, {\n            headers\n        });\n    } catch (error) {\n        console.error(\"[API] /api/expected-move error:\", error);\n        const errorResponse = (0,_lib_schemas__WEBPACK_IMPORTED_MODULE_1__.createApiResponse)(undefined, \"Internal server error\", error instanceof Error ? error.message : \"Unknown error\", \"Please check symbol format and try again\");\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(errorResponse, {\n            status: 500\n        });\n    }\n}\n/**\n * OPTIONS /api/expected-move - CORS preflight\n */ async function OPTIONS() {\n    return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n        status: 200,\n        headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"GET, OPTIONS\",\n            \"Access-Control-Allow-Headers\": \"Content-Type\"\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RixRQUFRRSxLQUFLLENBQUMsbUNBQW1DQTtRQUVqRCxNQUFNaUQsZ0JBQWdCN0gsK0RBQWlCQSxDQUNyQzBELFdBQ0EseUJBQ0FrQixpQkFBaUJrRCxRQUFRbEQsTUFBTW1ELE9BQU8sR0FBRyxpQkFDekM7UUFHRixPQUFPakkscURBQVlBLENBQUMrRCxJQUFJLENBQUNnRSxlQUFlO1lBQUU3RCxRQUFRO1FBQUk7SUFDeEQ7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZWdFO0lBQ3BCLE9BQU8sSUFBSWxJLHFEQUFZQSxDQUFDLE1BQU07UUFDNUJrRSxRQUFRO1FBQ1IyRCxTQUFTO1lBQ1AsK0JBQStCO1lBQy9CLGdDQUFnQztZQUNoQyxnQ0FBZ0M7UUFDbEM7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbnRpdi8uL2FwcC9hcGkvZXhwZWN0ZWQtbW92ZS9yb3V0ZS50cz9lOTIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogL2FwaS9leHBlY3RlZC1tb3ZlIC0gRXhwZWN0ZWQgbW92ZSBjYWxjdWxhdGlvbnMgZW5kcG9pbnRcbiAqIFJldHVybnMgZXhwZWN0ZWQgbW92ZSBkYXRhIHVzaW5nIHN0cmFkZGxlIGFuZCBJViBtZXRob2RzIHdpdGggY29uZmlkZW5jZSBhc3Nlc3NtZW50XG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IEV4cGVjdGVkTW92ZVJlcXVlc3RTY2hlbWEsIEV4cGVjdGVkTW92ZVJlc3BvbnNlU2NoZW1hLCBjcmVhdGVBcGlSZXNwb25zZSwgdmFsaWRhdGVSZXF1ZXN0IH0gZnJvbSAnQC9saWIvc2NoZW1hcyc7XG5pbXBvcnQgeyBDYWNoZUluc3RhbmNlcywgQ2FjaGVLZXlzIH0gZnJvbSAnQC9saWIvY2FjaGUvbHJ1JztcbmltcG9ydCB7IFJlZGlzQ2FjaGUsIEtleXMsIFF1YW50aXZDYWNoZSB9IGZyb20gJ0AvbGliL2NhY2hlL3JlZGlzJztcbmltcG9ydCB7IGZldGNoTGl2ZUV4cGVjdGVkTW92ZSwgaXNMaXZlRGF0YUF2YWlsYWJsZSB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2xpdmVEYXRhU2VydmljZSc7XG5pbXBvcnQgeyBjb21wdXRlRXhwZWN0ZWRNb3ZlLCBhc3Nlc3NDb25maWRlbmNlLCBmb3JtYXRFeHBlY3RlZE1vdmUgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9leHBlY3RlZE1vdmUnO1xuaW1wb3J0IHsgY2FsY3VsYXRlSVZTdGF0cywgY3JlYXRlTW9ja0lWSGlzdG9yeSB9IGZyb20gJ0AvbGliL3NlcnZpY2VzL2l2U3RhdHMnO1xuaW1wb3J0IHR5cGUgeyBDaGFpbkRhdGEgfSBmcm9tICdAL2xpYi9zZXJ2aWNlcy9leHBlY3RlZE1vdmUnO1xuXG4vKipcbiAqIE1vY2sgb3B0aW9ucyBkYXRhIHByb3ZpZGVyIChzaGFyZWQgbG9naWMgd2l0aCAvYXBpL29wdGlvbnMpXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGJlIGV4dHJhY3RlZCB0byBhIHNoYXJlZCBwcm92aWRlciBzZXJ2aWNlXG4gKi9cbmNsYXNzIE9wdGlvbnNQcm92aWRlciB7XG4gIHN0YXRpYyBhc3luYyBnZXRDaGFpbihzeW1ib2w6IHN0cmluZywgZXhwaXJ5Pzogc3RyaW5nKTogUHJvbWlzZTxDaGFpbkRhdGE+IHtcbiAgICAvLyBTaW11bGF0ZSBBUEkgZGVsYXlcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODApKTtcbiAgICBcbiAgICBjb25zdCBzcG90ID0gMTUwLjAwICsgTWF0aC5yYW5kb20oKSAqIDUwO1xuICAgIGNvbnN0IHNlbGVjdGVkRXhwaXJ5ID0gZXhwaXJ5IHx8ICcyMDI0LTAyLTE2JztcbiAgICBjb25zdCBleHBpcnlEYXRlID0gbmV3IERhdGUoc2VsZWN0ZWRFeHBpcnkpO1xuICAgIGNvbnN0IGRheXNUb0V4cGlyeSA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCgoZXhwaXJ5RGF0ZS5nZXRUaW1lKCkgLSBEYXRlLm5vdygpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSkpO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHN0cmlrZXMgYXJvdW5kIHNwb3QgcHJpY2VcbiAgICBjb25zdCBzdHJpa2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IGJhc2VTdHJpa2UgPSBNYXRoLnJvdW5kKHNwb3QgLyA1KSAqIDU7XG4gICAgZm9yIChsZXQgaSA9IC0xMDsgaSA8PSAxMDsgaSsrKSB7XG4gICAgICBzdHJpa2VzLnB1c2goYmFzZVN0cmlrZSArIChpICogNSkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSBtb2NrIG9wdGlvbnMgZGF0YSB3aXRoIHJlYWxpc3RpYyBwcmljaW5nXG4gICAgY29uc3QgY2FsbHMgPSBzdHJpa2VzLm1hcChzdHJpa2UgPT4ge1xuICAgICAgY29uc3QgaW50cmluc2ljID0gTWF0aC5tYXgoMCwgc3BvdCAtIHN0cmlrZSk7XG4gICAgICBjb25zdCB0aW1lVmFsdWUgPSBNYXRoLnJhbmRvbSgpICogMyArIDAuNTtcbiAgICAgIGNvbnN0IG1pZCA9IGludHJpbnNpYyArIHRpbWVWYWx1ZTtcbiAgICAgIGNvbnN0IHNwcmVhZCA9IE1hdGgubWF4KDAuMDEsIG1pZCAqIDAuMDQpOyAvLyA0JSBzcHJlYWRcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWtlLFxuICAgICAgICBtaWQsXG4gICAgICAgIGJpZDogTWF0aC5tYXgoMC4wMSwgbWlkIC0gc3ByZWFkIC8gMiksXG4gICAgICAgIGFzazogbWlkICsgc3ByZWFkIC8gMixcbiAgICAgICAgaXY6IDAuMjAgKyBNYXRoLnJhbmRvbSgpICogMC4zMCxcbiAgICAgICAgdm9sdW1lOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSxcbiAgICAgICAgb3BlbkludGVyZXN0OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBwdXRzID0gc3RyaWtlcy5tYXAoc3RyaWtlID0+IHtcbiAgICAgIGNvbnN0IGludHJpbnNpYyA9IE1hdGgubWF4KDAsIHN0cmlrZSAtIHNwb3QpO1xuICAgICAgY29uc3QgdGltZVZhbHVlID0gTWF0aC5yYW5kb20oKSAqIDMgKyAwLjU7XG4gICAgICBjb25zdCBtaWQgPSBpbnRyaW5zaWMgKyB0aW1lVmFsdWU7XG4gICAgICBjb25zdCBzcHJlYWQgPSBNYXRoLm1heCgwLjAxLCBtaWQgKiAwLjA0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyaWtlLFxuICAgICAgICBtaWQsXG4gICAgICAgIGJpZDogTWF0aC5tYXgoMC4wMSwgbWlkIC0gc3ByZWFkIC8gMiksXG4gICAgICAgIGFzazogbWlkICsgc3ByZWFkIC8gMixcbiAgICAgICAgaXY6IDAuMjAgKyBNYXRoLnJhbmRvbSgpICogMC4zMCxcbiAgICAgICAgdm9sdW1lOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwKSxcbiAgICAgICAgb3BlbkludGVyZXN0OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3BvdCxcbiAgICAgIGV4cGlyeURhdGU6IHNlbGVjdGVkRXhwaXJ5LFxuICAgICAgZGF5c1RvRXhwaXJ5LFxuICAgICAgc3RyaWtlcyxcbiAgICAgIGNhbGxzLFxuICAgICAgcHV0c1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHRVQgL2FwaS9leHBlY3RlZC1tb3ZlP3N5bWJvbD1BQVBMJmV4cGlyeT0yMDI0LTAxLTE5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gUGFyc2UgYW5kIHZhbGlkYXRlIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBzeW1ib2w6IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdzeW1ib2wnKSxcbiAgICAgIGV4cGlyeTogdXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2V4cGlyeScpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlUmVxdWVzdChFeHBlY3RlZE1vdmVSZXF1ZXN0U2NoZW1hLCBwYXJhbXMpO1xuICAgIGlmICghdmFsaWRhdGlvbi5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICAgIGNyZWF0ZUFwaVJlc3BvbnNlKHVuZGVmaW5lZCwgJ0ludmFsaWQgcmVxdWVzdCBwYXJhbWV0ZXJzJywgdmFsaWRhdGlvbi5kZXRhaWxzPy5qb2luKCcsICcpKSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB7IHN5bWJvbCwgZXhwaXJ5IH0gPSB2YWxpZGF0aW9uLmRhdGEhO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIGNhY2hlIGtleSBmb3IgZXhwZWN0ZWQgbW92ZVxuICAgIGNvbnN0IGVtQ2FjaGVLZXkgPSBDYWNoZUtleXMuZXhwZWN0ZWRNb3ZlKHN5bWJvbCwgZXhwaXJ5IHx8ICdkZWZhdWx0Jyk7XG4gICAgXG4gICAgLy8gVHJ5IEwxIGNhY2hlIGZpcnN0XG4gICAgbGV0IGV4cGVjdGVkTW92ZURhdGEgPSBDYWNoZUluc3RhbmNlcy5leHBlY3RlZE1vdmUuZ2V0KGVtQ2FjaGVLZXkpO1xuICAgIGxldCBjYWNoZUhpdCA9ICdsMSc7XG4gICAgXG4gICAgaWYgKCFleHBlY3RlZE1vdmVEYXRhKSB7XG4gICAgICAvLyBUcnkgTDIgKFJlZGlzKSBjYWNoZVxuICAgICAgY29uc3QgcmVkaXNLZXkgPSBLZXlzLmV4cGVjdGVkTW92ZVNuYXBzaG90KHN5bWJvbCwgZXhwaXJ5IHx8ICdkZWZhdWx0Jyk7XG4gICAgICBleHBlY3RlZE1vdmVEYXRhID0gYXdhaXQgUmVkaXNDYWNoZS5nZXRKc29uKHJlZGlzS2V5KTtcbiAgICAgIGNhY2hlSGl0ID0gZXhwZWN0ZWRNb3ZlRGF0YSA/ICdsMicgOiAnbWlzcyc7XG4gICAgICBcbiAgICAgIGlmICghZXhwZWN0ZWRNb3ZlRGF0YSkge1xuICAgICAgICAvLyBUcnkgdG8gZmV0Y2ggbGl2ZSBleHBlY3RlZCBtb3ZlIGRhdGEgZmlyc3RcbiAgICAgICAgbGV0IGxpdmVFeHBlY3RlZE1vdmVEYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTGl2ZURhdGFBdmFpbGFibGUoKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsaXZlRXhwZWN0ZWRNb3ZlRGF0YSA9IGF3YWl0IGZldGNoTGl2ZUV4cGVjdGVkTW92ZShzeW1ib2wpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtleHBlY3RlZC1tb3ZlLWFwaV0gTGl2ZSBkYXRhICR7bGl2ZUV4cGVjdGVkTW92ZURhdGEgPyAnZm91bmQnIDogJ25vdCBmb3VuZCd9IGZvciAke3N5bWJvbH1gKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbZXhwZWN0ZWQtbW92ZS1hcGldIExpdmUgZGF0YSBmZXRjaCBmYWlsZWQgZm9yICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBsaXZlIGRhdGEsIHVzZSBpdFxuICAgICAgICBpZiAobGl2ZUV4cGVjdGVkTW92ZURhdGEpIHtcbiAgICAgICAgICBleHBlY3RlZE1vdmVEYXRhID0ge1xuICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgICBkYWlseTogbGl2ZUV4cGVjdGVkTW92ZURhdGEuc3VtbWFyeS5kYWlseSxcbiAgICAgICAgICAgICAgd2Vla2x5OiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5zdW1tYXJ5LndlZWtseSxcbiAgICAgICAgICAgICAgbW9udGhseTogbGl2ZUV4cGVjdGVkTW92ZURhdGEuc3VtbWFyeS5tb250aGx5XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RyYWRkbGU6IHtcbiAgICAgICAgICAgICAgcHJpY2U6IGxpdmVFeHBlY3RlZE1vdmVEYXRhLnN0cmFkZGxlLnByaWNlLFxuICAgICAgICAgICAgICBtb3ZlOiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5zdHJhZGRsZS5tb3ZlLFxuICAgICAgICAgICAgICBtb3ZlUGVyY2VudDogbGl2ZUV4cGVjdGVkTW92ZURhdGEuc3RyYWRkbGUubW92ZVBlcmNlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpdjoge1xuICAgICAgICAgICAgICByYW5rOiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5pdi5yYW5rLFxuICAgICAgICAgICAgICBwZXJjZW50aWxlOiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5pdi5wZXJjZW50aWxlLFxuICAgICAgICAgICAgICBjdXJyZW50OiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5pdi5jdXJyZW50LFxuICAgICAgICAgICAgICBoaWdoNTJXZWVrOiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS5pdi5oaWdoNTJXZWVrLFxuICAgICAgICAgICAgICBsb3c1MldlZWs6IGxpdmVFeHBlY3RlZE1vdmVEYXRhLml2LmxvdzUyV2Vla1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6ICdoaWdoJyBhcyBjb25zdCxcbiAgICAgICAgICAgIG1ldGhvZDogJ3N0cmFkZGxlJyBhcyBjb25zdCxcbiAgICAgICAgICAgIHRpbWVUb0V4cGlyeTogbGl2ZUV4cGVjdGVkTW92ZURhdGEudGltZVRvRXhwaXJ5LFxuICAgICAgICAgICAgdW5kZXJseWluZ1ByaWNlOiBsaXZlRXhwZWN0ZWRNb3ZlRGF0YS51bmRlcmx5aW5nUHJpY2UsXG4gICAgICAgICAgICBpbXBsaWVkVm9sYXRpbGl0eTogbGl2ZUV4cGVjdGVkTW92ZURhdGEuaW1wbGllZFZvbGF0aWxpdHlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gQ2FjaGUgdGhlIGxpdmUgZGF0YVxuICAgICAgICAgIENhY2hlSW5zdGFuY2VzLmV4cGVjdGVkTW92ZS5zZXQoZW1DYWNoZUtleSwgZXhwZWN0ZWRNb3ZlRGF0YSk7XG4gICAgICAgICAgYXdhaXQgUmVkaXNDYWNoZS5zZXRKc29uKEtleXMuZXhwZWN0ZWRNb3ZlU25hcHNob3Qoc3ltYm9sLCBleHBpcnkgfHwgJ2RlZmF1bHQnKSwgZXhwZWN0ZWRNb3ZlRGF0YSwgMzAwKTsgLy8gNSBtaW4gVFRMIGZvciBsaXZlIGRhdGFcblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY3JlYXRlQXBpUmVzcG9uc2UoZXhwZWN0ZWRNb3ZlRGF0YSk7XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIG1pc3MgLSBjYWxjdWxhdGUgZXhwZWN0ZWQgbW92ZSB1c2luZyBtb2NrIGRhdGFcbiAgICAgICAgXG4gICAgICAgIC8vIEZpcnN0LCBnZXQgb3B0aW9ucyBjaGFpbiBkYXRhXG4gICAgICAgIGNvbnN0IGNoYWluQ2FjaGVLZXkgPSBDYWNoZUtleXMub3B0aW9uc0NoYWluKHN5bWJvbCwgZXhwaXJ5IHx8ICdkZWZhdWx0Jyk7XG4gICAgICAgIGxldCBjaGFpbkRhdGEgPSBDYWNoZUluc3RhbmNlcy5vcHRpb25zQ2hhaW4uZ2V0KGNoYWluQ2FjaGVLZXkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjaGFpbkRhdGEpIHtcbiAgICAgICAgICAvLyBUcnkgUmVkaXMgZm9yIGNoYWluIGRhdGFcbiAgICAgICAgICBjb25zdCBjaGFpblJlZGlzS2V5ID0gS2V5cy5vcHRpb25zQ2hhaW4oc3ltYm9sLCBleHBpcnkgfHwgJ2RlZmF1bHQnKTtcbiAgICAgICAgICBjaGFpbkRhdGEgPSBhd2FpdCBSZWRpc0NhY2hlLmdldEpzb248Q2hhaW5EYXRhPihjaGFpblJlZGlzS2V5KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWNoYWluRGF0YSkge1xuICAgICAgICAgICAgLy8gRmV0Y2ggZnJlc2ggY2hhaW4gZGF0YVxuICAgICAgICAgICAgY2hhaW5EYXRhID0gYXdhaXQgT3B0aW9uc1Byb3ZpZGVyLmdldENoYWluKHN5bWJvbCwgZXhwaXJ5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FjaGUgY2hhaW4gZGF0YVxuICAgICAgICAgICAgQ2FjaGVJbnN0YW5jZXMub3B0aW9uc0NoYWluLnNldChjaGFpbkNhY2hlS2V5LCBjaGFpbkRhdGEsIDYwICogMTAwMCk7XG4gICAgICAgICAgICBhd2FpdCBSZWRpc0NhY2hlLnNldEpzb24oY2hhaW5SZWRpc0tleSwgY2hhaW5EYXRhLCAzMDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYWNoZSBpbiBMMVxuICAgICAgICAgICAgQ2FjaGVJbnN0YW5jZXMub3B0aW9uc0NoYWluLnNldChjaGFpbkNhY2hlS2V5LCBjaGFpbkRhdGEsIDYwICogMTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgZXhwZWN0ZWQgbW92ZVxuICAgICAgICBjb25zdCBleHBlY3RlZE1vdmUgPSBjb21wdXRlRXhwZWN0ZWRNb3ZlKGNoYWluRGF0YSBhcyBDaGFpbkRhdGEpO1xuICAgICAgICBjb25zdCBjb25maWRlbmNlID0gYXNzZXNzQ29uZmlkZW5jZShjaGFpbkRhdGEgYXMgQ2hhaW5EYXRhLCAoZXhwZWN0ZWRNb3ZlIGFzIGFueSkuYXRtKTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdGVkTW92ZURhdGEgPSB7XG4gICAgICAgICAgLi4uZXhwZWN0ZWRNb3ZlLFxuICAgICAgICAgIGNvbmZpZGVuY2UsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgc3ltYm9sOiBzeW1ib2xcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhY2hlIGV4cGVjdGVkIG1vdmUgaW4gYm90aCBsYXllcnNcbiAgICAgICAgQ2FjaGVJbnN0YW5jZXMuZXhwZWN0ZWRNb3ZlLnNldChlbUNhY2hlS2V5LCBleHBlY3RlZE1vdmVEYXRhLCA5MCAqIDEwMDApOyAvLyAxLjUgbWludXRlcyBMMVxuICAgICAgICBhd2FpdCBRdWFudGl2Q2FjaGUuY2FjaGVFeHBlY3RlZE1vdmUoc3ltYm9sLCBleHBpcnkgfHwgJ2RlZmF1bHQnLCBleHBlY3RlZE1vdmVEYXRhLCAxODApOyAvLyAzIG1pbnV0ZXMgTDJcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCB0byB0b3AgbW92ZXJzIGlmIHNpZ25pZmljYW50IG1vdmVcbiAgICAgICAgaWYgKChleHBlY3RlZE1vdmVEYXRhIGFzIGFueSk/LnN0cmFkZGxlPy5wY3QgPiA1LjApIHtcbiAgICAgICAgICBhd2FpdCBRdWFudGl2Q2FjaGUuYWRkVG9wTW92ZXIoc3ltYm9sLCAoZXhwZWN0ZWRNb3ZlRGF0YSBhcyBhbnkpLnN0cmFkZGxlLnBjdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNhY2hlSGl0ID0gJ21pc3MnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FjaGUgaW4gTDEgZm9yIG5leHQgdGltZVxuICAgICAgICBDYWNoZUluc3RhbmNlcy5leHBlY3RlZE1vdmUuc2V0KGVtQ2FjaGVLZXksIGV4cGVjdGVkTW92ZURhdGEsIDkwICogMTAwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBJViByYW5rIGRhdGEgKG1vY2sgZm9yIG5vdylcbiAgICBjb25zdCBpdkNhY2hlS2V5ID0gQ2FjaGVLZXlzLml2U2VyaWVzKHN5bWJvbCwgMjUyKTsgLy8gMSB5ZWFyIG9mIGRhdGFcbiAgICBsZXQgaXZTdGF0cyA9IENhY2hlSW5zdGFuY2VzLml2U2VyaWVzLmdldChpdkNhY2hlS2V5KTtcbiAgICBcbiAgICBpZiAoIWl2U3RhdHMpIHtcbiAgICAgIC8vIEdlbmVyYXRlIG1vY2sgSVYgZGF0YSBhbmQgY2FsY3VsYXRlIHN0YXRzXG4gICAgICBjb25zdCBpdkhpc3RvcnkgPSBjcmVhdGVNb2NrSVZIaXN0b3J5KDI1MiwgMC4yNSk7IC8vIDEgeWVhclxuICAgICAgY29uc3QgY3VycmVudElWID0gKGV4cGVjdGVkTW92ZURhdGEgYXMgYW55KT8uYXRtPy5pdiB8fCAwLjI1O1xuICAgICAgXG4gICAgICBpdlN0YXRzID0gY2FsY3VsYXRlSVZTdGF0cyhpdkhpc3RvcnksIGN1cnJlbnRJVik7XG4gICAgICBcbiAgICAgIC8vIENhY2hlIElWIHN0YXRzXG4gICAgICBDYWNoZUluc3RhbmNlcy5pdlNlcmllcy5zZXQoaXZDYWNoZUtleSwgaXZTdGF0cywgMTgwMCAqIDEwMDApOyAvLyAzMCBtaW51dGVzXG4gICAgICBhd2FpdCBSZWRpc0NhY2hlLnNldEpzb24oS2V5cy5pdlNlcmllcyhzeW1ib2wpLCBpdlN0YXRzLCAxODAwKTsgLy8gMzAgbWludXRlc1xuICAgIH1cbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gZGF0YSB0byBtYXRjaCBFeHBlY3RlZE1vdmVDYXJkIGNvbXBvbmVudCBleHBlY3RhdGlvbnNcbiAgICBjb25zdCBzcG90UHJpY2UgPSAoZXhwZWN0ZWRNb3ZlRGF0YSBhcyBhbnkpPy5hdG0/LnNwb3QgfHwgMTUwO1xuICAgIGNvbnN0IHN0cmFkZGxlTW92ZSA9IChleHBlY3RlZE1vdmVEYXRhIGFzIGFueSk/LnN0cmFkZGxlO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gY3JlYXRlQXBpUmVzcG9uc2Uoe1xuICAgICAgc3ltYm9sOiBzeW1ib2wsXG4gICAgICBzcG90UHJpY2U6IHNwb3RQcmljZSxcbiAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgZGFpbHk6IHN0cmFkZGxlTW92ZSA/IHtcbiAgICAgICAgICBtb3ZlOiBzdHJhZGRsZU1vdmUuYWJzLFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IHN0cmFkZGxlTW92ZS5wY3QsXG4gICAgICAgICAgbG93ZXI6IHNwb3RQcmljZSAtIHN0cmFkZGxlTW92ZS5hYnMsXG4gICAgICAgICAgdXBwZXI6IHNwb3RQcmljZSArIHN0cmFkZGxlTW92ZS5hYnNcbiAgICAgICAgfSA6IG51bGwsXG4gICAgICAgIHdlZWtseTogc3RyYWRkbGVNb3ZlID8ge1xuICAgICAgICAgIG1vdmU6IHN0cmFkZGxlTW92ZS5hYnMgKiAyLjY1LCAvLyBBcHByb3hpbWF0ZSB3ZWVrbHkgc2NhbGluZ1xuICAgICAgICAgIHBlcmNlbnRhZ2U6IHN0cmFkZGxlTW92ZS5wY3QgKiAyLjY1LFxuICAgICAgICAgIGxvd2VyOiBzcG90UHJpY2UgLSAoc3RyYWRkbGVNb3ZlLmFicyAqIDIuNjUpLFxuICAgICAgICAgIHVwcGVyOiBzcG90UHJpY2UgKyAoc3RyYWRkbGVNb3ZlLmFicyAqIDIuNjUpXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBtb250aGx5OiBzdHJhZGRsZU1vdmUgPyB7XG4gICAgICAgICAgbW92ZTogc3RyYWRkbGVNb3ZlLmFicyAqIDUuNDgsIC8vIEFwcHJveGltYXRlIG1vbnRobHkgc2NhbGluZyAoc3FydCgzMCkpXG4gICAgICAgICAgcGVyY2VudGFnZTogc3RyYWRkbGVNb3ZlLnBjdCAqIDUuNDgsXG4gICAgICAgICAgbG93ZXI6IHNwb3RQcmljZSAtIChzdHJhZGRsZU1vdmUuYWJzICogNS40OCksXG4gICAgICAgICAgdXBwZXI6IHNwb3RQcmljZSArIChzdHJhZGRsZU1vdmUuYWJzICogNS40OClcbiAgICAgICAgfSA6IG51bGxcbiAgICAgIH0sXG4gICAgICAvLyBBbHNvIGluY2x1ZGUgdGhlIHJhdyBkYXRhIGZvciBvdGhlciBjb21wb25lbnRzIHRoYXQgbWlnaHQgbmVlZCBpdFxuICAgICAgZW06IGV4cGVjdGVkTW92ZURhdGEsXG4gICAgICBpdlJhbms6IGl2U3RhdHNcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgXG4gICAgLy8gQWRkIHBlcmZvcm1hbmNlIGhlYWRlcnNcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDYWNoZS1Db250cm9sJzogJ3B1YmxpYywgcy1tYXhhZ2U9OTAsIHN0YWxlLXdoaWxlLXJldmFsaWRhdGU9MzAwJyxcbiAgICAgICdYLUNhY2hlLUhpdCc6IGNhY2hlSGl0LFxuICAgICAgJ1gtUHJvY2Vzc2luZy1UaW1lJzogYCR7cHJvY2Vzc2luZ1RpbWV9bXNgLFxuICAgICAgJ1gtU3ltYm9sJzogc3ltYm9sLFxuICAgICAgJ1gtRXhwaXJ5JzogKGV4cGVjdGVkTW92ZURhdGEgYXMgYW55KT8uYXRtPy5leHBpcnkgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3BvbnNlLCB7IGhlYWRlcnMgfSk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW0FQSV0gL2FwaS9leHBlY3RlZC1tb3ZlIGVycm9yOicsIGVycm9yKTtcbiAgICBcbiAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gY3JlYXRlQXBpUmVzcG9uc2UoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAnSW50ZXJuYWwgc2VydmVyIGVycm9yJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InLFxuICAgICAgJ1BsZWFzZSBjaGVjayBzeW1ib2wgZm9ybWF0IGFuZCB0cnkgYWdhaW4nXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oZXJyb3JSZXNwb25zZSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuXG4vKipcbiAqIE9QVElPTlMgL2FwaS9leHBlY3RlZC1tb3ZlIC0gQ09SUyBwcmVmbGlnaHRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIE9QVElPTlMoKSB7XG4gIHJldHVybiBuZXcgTmV4dFJlc3BvbnNlKG51bGwsIHtcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonLFxuICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnOiAnR0VULCBPUFRJT05TJyxcbiAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZScsXG4gICAgfSxcbiAgfSk7XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiRXhwZWN0ZWRNb3ZlUmVxdWVzdFNjaGVtYSIsImNyZWF0ZUFwaVJlc3BvbnNlIiwidmFsaWRhdGVSZXF1ZXN0IiwiQ2FjaGVJbnN0YW5jZXMiLCJDYWNoZUtleXMiLCJSZWRpc0NhY2hlIiwiS2V5cyIsIlF1YW50aXZDYWNoZSIsImZldGNoTGl2ZUV4cGVjdGVkTW92ZSIsImlzTGl2ZURhdGFBdmFpbGFibGUiLCJjb21wdXRlRXhwZWN0ZWRNb3ZlIiwiYXNzZXNzQ29uZmlkZW5jZSIsImNhbGN1bGF0ZUlWU3RhdHMiLCJjcmVhdGVNb2NrSVZIaXN0b3J5IiwiT3B0aW9uc1Byb3ZpZGVyIiwiZ2V0Q2hhaW4iLCJzeW1ib2wiLCJleHBpcnkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJzcG90IiwiTWF0aCIsInJhbmRvbSIsInNlbGVjdGVkRXhwaXJ5IiwiZXhwaXJ5RGF0ZSIsIkRhdGUiLCJkYXlzVG9FeHBpcnkiLCJtYXgiLCJjZWlsIiwiZ2V0VGltZSIsIm5vdyIsInN0cmlrZXMiLCJiYXNlU3RyaWtlIiwicm91bmQiLCJpIiwicHVzaCIsImNhbGxzIiwibWFwIiwic3RyaWtlIiwiaW50cmluc2ljIiwidGltZVZhbHVlIiwibWlkIiwic3ByZWFkIiwiYmlkIiwiYXNrIiwiaXYiLCJ2b2x1bWUiLCJmbG9vciIsIm9wZW5JbnRlcmVzdCIsInB1dHMiLCJHRVQiLCJyZXF1ZXN0Iiwic3RhcnRUaW1lIiwidXJsIiwiVVJMIiwicGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwidW5kZWZpbmVkIiwidmFsaWRhdGlvbiIsInN1Y2Nlc3MiLCJqc29uIiwiZGV0YWlscyIsImpvaW4iLCJzdGF0dXMiLCJkYXRhIiwiZW1DYWNoZUtleSIsImV4cGVjdGVkTW92ZSIsImV4cGVjdGVkTW92ZURhdGEiLCJjYWNoZUhpdCIsInJlZGlzS2V5IiwiZXhwZWN0ZWRNb3ZlU25hcHNob3QiLCJnZXRKc29uIiwibGl2ZUV4cGVjdGVkTW92ZURhdGEiLCJjb25zb2xlIiwibG9nIiwiZXJyb3IiLCJ3YXJuIiwic3VtbWFyeSIsImRhaWx5Iiwid2Vla2x5IiwibW9udGhseSIsInN0cmFkZGxlIiwicHJpY2UiLCJtb3ZlIiwibW92ZVBlcmNlbnQiLCJyYW5rIiwicGVyY2VudGlsZSIsImN1cnJlbnQiLCJoaWdoNTJXZWVrIiwibG93NTJXZWVrIiwiY29uZmlkZW5jZSIsIm1ldGhvZCIsInRpbWVUb0V4cGlyeSIsInVuZGVybHlpbmdQcmljZSIsImltcGxpZWRWb2xhdGlsaXR5Iiwic2V0Iiwic2V0SnNvbiIsInJlc3BvbnNlIiwiY2hhaW5DYWNoZUtleSIsIm9wdGlvbnNDaGFpbiIsImNoYWluRGF0YSIsImNoYWluUmVkaXNLZXkiLCJhdG0iLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsImNhY2hlRXhwZWN0ZWRNb3ZlIiwicGN0IiwiYWRkVG9wTW92ZXIiLCJpdkNhY2hlS2V5IiwiaXZTZXJpZXMiLCJpdlN0YXRzIiwiaXZIaXN0b3J5IiwiY3VycmVudElWIiwic3BvdFByaWNlIiwic3RyYWRkbGVNb3ZlIiwiYWJzIiwicGVyY2VudGFnZSIsImxvd2VyIiwidXBwZXIiLCJlbSIsIml2UmFuayIsInByb2Nlc3NpbmdUaW1lIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJlcnJvclJlc3BvbnNlIiwiRXJyb3IiLCJtZXNzYWdlIiwiT1BUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/expected-move/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/cache/lru.ts":
/*!**************************!*\
  !*** ./lib/cache/lru.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheInstances: () => (/* binding */ CacheInstances),\n/* harmony export */   CacheKeys: () => (/* binding */ CacheKeys),\n/* harmony export */   QuantivLRUCache: () => (/* binding */ QuantivLRUCache),\n/* harmony export */   clearAllCaches: () => (/* binding */ clearAllCaches),\n/* harmony export */   getAllCacheStats: () => (/* binding */ getAllCacheStats)\n/* harmony export */ });\n/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/dist/esm/index.js\");\n/**\n * LRU Cache for L1 (in-process) caching\n * Used for fast API response caching within each API route\n */ \n/**\n * Generic LRU cache wrapper with TTL and statistics\n */ class QuantivLRUCache {\n    constructor(name, options = {}){\n        this.hits = 0;\n        this.misses = 0;\n        this.name = name;\n        this.cache = new lru_cache__WEBPACK_IMPORTED_MODULE_0__.LRUCache({\n            max: options.maxSize || 100,\n            ttl: options.ttlMs || 60 * 1000,\n            updateAgeOnGet: options.updateAgeOnGet ?? true,\n            dispose: (value, key)=>{\n                // Optional cleanup when items are evicted\n                console.debug(`[${this.name}] Evicted cache entry: ${key}`);\n            }\n        });\n    }\n    /**\n   * Get item from cache\n   */ get(key) {\n        const entry = this.cache.get(key);\n        if (entry) {\n            this.hits++;\n            return entry.data;\n        } else {\n            this.misses++;\n            return null;\n        }\n    }\n    /**\n   * Set item in cache\n   */ set(key, data, ttlMs) {\n        const entry = {\n            data,\n            timestamp: Date.now(),\n            key\n        };\n        if (ttlMs) {\n            this.cache.set(key, entry, {\n                ttl: ttlMs\n            });\n        } else {\n            this.cache.set(key, entry);\n        }\n    }\n    /**\n   * Check if key exists in cache\n   */ has(key) {\n        return this.cache.has(key);\n    }\n    /**\n   * Delete item from cache\n   */ delete(key) {\n        return this.cache.delete(key);\n    }\n    /**\n   * Clear all items from cache\n   */ clear() {\n        this.cache.clear();\n        this.hits = 0;\n        this.misses = 0;\n    }\n    /**\n   * Get cache statistics\n   */ getStats() {\n        const total = this.hits + this.misses;\n        return {\n            name: this.name,\n            size: this.cache.size,\n            maxSize: this.cache.max,\n            hits: this.hits,\n            misses: this.misses,\n            hitRate: total > 0 ? this.hits / total * 100 : 0,\n            calculatedSize: this.cache.calculatedSize || 0\n        };\n    }\n    /**\n   * Get or set pattern - fetch data if not in cache\n   */ async getOrSet(key, fetchFn, ttlMs) {\n        const cached = this.get(key);\n        if (cached !== null) {\n            return cached;\n        }\n        try {\n            const data = await fetchFn();\n            this.set(key, data, ttlMs);\n            return data;\n        } catch (error) {\n            console.error(`[${this.name}] Error fetching data for key ${key}:`, error);\n            throw error;\n        }\n    }\n    /**\n   * Peek at item without updating LRU order\n   */ peek(key) {\n        const entry = this.cache.peek(key);\n        return entry ? entry.data : null;\n    }\n    /**\n   * Get all keys in cache\n   */ keys() {\n        return Array.from(this.cache.keys());\n    }\n    /**\n   * Get cache info for debugging\n   */ getInfo() {\n        const entries = [];\n        const now = Date.now();\n        // Convert iterator to array to avoid downlevelIteration issues\n        const cacheEntries = Array.from(this.cache.entries());\n        for (const [key, entry] of cacheEntries){\n            entries.push({\n                key,\n                timestamp: entry.timestamp,\n                age: now - entry.timestamp\n            });\n        }\n        return {\n            name: this.name,\n            entries,\n            stats: this.getStats()\n        };\n    }\n}\n/**\n * Pre-configured cache instances for different data types\n */ const CacheInstances = {\n    // Options chain cache - larger size, shorter TTL\n    optionsChain: new QuantivLRUCache(\"options-chain\", {\n        maxSize: 200,\n        ttlMs: 60 * 1000,\n        updateAgeOnGet: true\n    }),\n    // Expected move cache - medium size, medium TTL\n    expectedMove: new QuantivLRUCache(\"expected-move\", {\n        maxSize: 150,\n        ttlMs: 90 * 1000,\n        updateAgeOnGet: true\n    }),\n    // Earnings data cache - smaller size, longer TTL\n    earnings: new QuantivLRUCache(\"earnings\", {\n        maxSize: 100,\n        ttlMs: 300 * 1000,\n        updateAgeOnGet: true\n    }),\n    // Price history cache - smaller size, longer TTL\n    priceHistory: new QuantivLRUCache(\"price-history\", {\n        maxSize: 50,\n        ttlMs: 600 * 1000,\n        updateAgeOnGet: false // Don't update age for historical data\n    }),\n    // IV series cache - medium size, longer TTL\n    ivSeries: new QuantivLRUCache(\"iv-series\", {\n        maxSize: 100,\n        ttlMs: 1800 * 1000,\n        updateAgeOnGet: false\n    })\n};\n/**\n * Get all cache statistics for monitoring\n */ function getAllCacheStats() {\n    return {\n        optionsChain: CacheInstances.optionsChain.getStats(),\n        expectedMove: CacheInstances.expectedMove.getStats(),\n        earnings: CacheInstances.earnings.getStats(),\n        priceHistory: CacheInstances.priceHistory.getStats(),\n        ivSeries: CacheInstances.ivSeries.getStats()\n    };\n}\n/**\n * Clear all caches (useful for testing or manual cache invalidation)\n */ function clearAllCaches() {\n    Object.values(CacheInstances).forEach((cache)=>cache.clear());\n}\n/**\n * Utility to generate cache keys for different data types\n */ const CacheKeys = {\n    optionsChain: (symbol, expiry)=>`${symbol.toUpperCase()}:${expiry}`,\n    expectedMove: (symbol, expiry)=>`${symbol.toUpperCase()}:${expiry}`,\n    earnings: (symbol)=>symbol.toUpperCase(),\n    priceHistory: (symbol, days)=>`${symbol.toUpperCase()}:${days}d`,\n    ivSeries: (symbol, days)=>`${symbol.toUpperCase()}:${days}d`\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkEsT0FBT0UsV0FBVztJQUNoRFYsY0FBYyxDQUFDUSxRQUFnQkcsT0FBaUIsQ0FBQyxFQUFFSCxPQUFPRSxXQUFXLEdBQUcsQ0FBQyxFQUFFQyxLQUFLLENBQUMsQ0FBQztJQUNsRlYsVUFBVSxDQUFDTyxRQUFnQkcsT0FBaUIsQ0FBQyxFQUFFSCxPQUFPRSxXQUFXLEdBQUcsQ0FBQyxFQUFFQyxLQUFLLENBQUMsQ0FBQztBQUNoRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbnRpdi8uL2xpYi9jYWNoZS9scnUudHM/ZjU4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExSVSBDYWNoZSBmb3IgTDEgKGluLXByb2Nlc3MpIGNhY2hpbmdcbiAqIFVzZWQgZm9yIGZhc3QgQVBJIHJlc3BvbnNlIGNhY2hpbmcgd2l0aGluIGVhY2ggQVBJIHJvdXRlXG4gKi9cblxuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tICdscnUtY2FjaGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlT3B0aW9ucyB7XG4gIG1heFNpemU/OiBudW1iZXI7XG4gIHR0bE1zPzogbnVtYmVyO1xuICB1cGRhdGVBZ2VPbkdldD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FjaGVFbnRyeTxUPiB7XG4gIGRhdGE6IFQ7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBrZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBHZW5lcmljIExSVSBjYWNoZSB3cmFwcGVyIHdpdGggVFRMIGFuZCBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBjbGFzcyBRdWFudGl2TFJVQ2FjaGU8VD4ge1xuICBwcml2YXRlIGNhY2hlOiBMUlVDYWNoZTxzdHJpbmcsIENhY2hlRW50cnk8VD4+O1xuICBwcml2YXRlIGhpdHM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgbWlzc2VzOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIG5hbWU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IENhY2hlT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmNhY2hlID0gbmV3IExSVUNhY2hlKHtcbiAgICAgIG1heDogb3B0aW9ucy5tYXhTaXplIHx8IDEwMCxcbiAgICAgIHR0bDogb3B0aW9ucy50dGxNcyB8fCA2MCAqIDEwMDAsIC8vIDEgbWludXRlIGRlZmF1bHRcbiAgICAgIHVwZGF0ZUFnZU9uR2V0OiBvcHRpb25zLnVwZGF0ZUFnZU9uR2V0ID8/IHRydWUsXG4gICAgICBkaXNwb3NlOiAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAvLyBPcHRpb25hbCBjbGVhbnVwIHdoZW4gaXRlbXMgYXJlIGV2aWN0ZWRcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhgWyR7dGhpcy5uYW1lfV0gRXZpY3RlZCBjYWNoZSBlbnRyeTogJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGl0ZW0gZnJvbSBjYWNoZVxuICAgKi9cbiAgZ2V0KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICBcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIHRoaXMuaGl0cysrO1xuICAgICAgcmV0dXJuIGVudHJ5LmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWlzc2VzKys7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IGl0ZW0gaW4gY2FjaGVcbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogVCwgdHRsTXM/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBlbnRyeTogQ2FjaGVFbnRyeTxUPiA9IHtcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBrZXlcbiAgICB9O1xuXG4gICAgaWYgKHR0bE1zKSB7XG4gICAgICB0aGlzLmNhY2hlLnNldChrZXksIGVudHJ5LCB7IHR0bDogdHRsTXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBrZXkgZXhpc3RzIGluIGNhY2hlXG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgaXRlbSBmcm9tIGNhY2hlXG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgaXRlbXMgZnJvbSBjYWNoZVxuICAgKi9cbiAgY2xlYXIoKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuaGl0cyA9IDA7XG4gICAgdGhpcy5taXNzZXMgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzdGF0aXN0aWNzXG4gICAqL1xuICBnZXRTdGF0cygpOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHNpemU6IG51bWJlcjtcbiAgICBtYXhTaXplOiBudW1iZXI7XG4gICAgaGl0czogbnVtYmVyO1xuICAgIG1pc3NlczogbnVtYmVyO1xuICAgIGhpdFJhdGU6IG51bWJlcjtcbiAgICBjYWxjdWxhdGVkU2l6ZTogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuaGl0cyArIHRoaXMubWlzc2VzO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBzaXplOiB0aGlzLmNhY2hlLnNpemUsXG4gICAgICBtYXhTaXplOiB0aGlzLmNhY2hlLm1heCxcbiAgICAgIGhpdHM6IHRoaXMuaGl0cyxcbiAgICAgIG1pc3NlczogdGhpcy5taXNzZXMsXG4gICAgICBoaXRSYXRlOiB0b3RhbCA+IDAgPyAodGhpcy5oaXRzIC8gdG90YWwpICogMTAwIDogMCxcbiAgICAgIGNhbGN1bGF0ZWRTaXplOiB0aGlzLmNhY2hlLmNhbGN1bGF0ZWRTaXplIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvciBzZXQgcGF0dGVybiAtIGZldGNoIGRhdGEgaWYgbm90IGluIGNhY2hlXG4gICAqL1xuICBhc3luYyBnZXRPclNldDxLPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBmZXRjaEZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIHR0bE1zPzogbnVtYmVyXG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuZ2V0KGtleSk7XG4gICAgXG4gICAgaWYgKGNhY2hlZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoRm4oKTtcbiAgICAgIHRoaXMuc2V0KGtleSwgZGF0YSwgdHRsTXMpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFske3RoaXMubmFtZX1dIEVycm9yIGZldGNoaW5nIGRhdGEgZm9yIGtleSAke2tleX06YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlZWsgYXQgaXRlbSB3aXRob3V0IHVwZGF0aW5nIExSVSBvcmRlclxuICAgKi9cbiAgcGVlayhrZXk6IHN0cmluZyk6IFQgfCBudWxsIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXMuY2FjaGUucGVlayhrZXkpO1xuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5LmRhdGEgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwga2V5cyBpbiBjYWNoZVxuICAgKi9cbiAga2V5cygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jYWNoZS5rZXlzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBpbmZvIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIGdldEluZm8oKToge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbnRyaWVzOiBBcnJheTx7XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIHRpbWVzdGFtcDogbnVtYmVyO1xuICAgICAgYWdlOiBudW1iZXI7XG4gICAgfT47XG4gICAgc3RhdHM6IHtcbiAgICAgIGhpdHM6IG51bWJlcjtcbiAgICAgIG1pc3NlczogbnVtYmVyO1xuICAgICAgaGl0UmF0ZTogbnVtYmVyO1xuICAgICAgc2l6ZTogbnVtYmVyO1xuICAgICAgbWF4U2l6ZTogbnVtYmVyO1xuICAgIH07XG4gIH0ge1xuICAgIGNvbnN0IGVudHJpZXM6IEFycmF5PHsga2V5OiBzdHJpbmc7IHRpbWVzdGFtcDogbnVtYmVyOyBhZ2U6IG51bWJlciB9PiA9IFtdO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQ29udmVydCBpdGVyYXRvciB0byBhcnJheSB0byBhdm9pZCBkb3dubGV2ZWxJdGVyYXRpb24gaXNzdWVzXG4gICAgY29uc3QgY2FjaGVFbnRyaWVzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLmVudHJpZXMoKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgY2FjaGVFbnRyaWVzKSB7XG4gICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHRpbWVzdGFtcDogZW50cnkudGltZXN0YW1wLFxuICAgICAgICBhZ2U6IG5vdyAtIGVudHJ5LnRpbWVzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGVudHJpZXMsXG4gICAgICBzdGF0czogdGhpcy5nZXRTdGF0cygpXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFByZS1jb25maWd1cmVkIGNhY2hlIGluc3RhbmNlcyBmb3IgZGlmZmVyZW50IGRhdGEgdHlwZXNcbiAqL1xuZXhwb3J0IGNvbnN0IENhY2hlSW5zdGFuY2VzID0ge1xuICAvLyBPcHRpb25zIGNoYWluIGNhY2hlIC0gbGFyZ2VyIHNpemUsIHNob3J0ZXIgVFRMXG4gIG9wdGlvbnNDaGFpbjogbmV3IFF1YW50aXZMUlVDYWNoZSgnb3B0aW9ucy1jaGFpbicsIHtcbiAgICBtYXhTaXplOiAyMDAsXG4gICAgdHRsTXM6IDYwICogMTAwMCwgLy8gMSBtaW51dGVcbiAgICB1cGRhdGVBZ2VPbkdldDogdHJ1ZVxuICB9KSxcblxuICAvLyBFeHBlY3RlZCBtb3ZlIGNhY2hlIC0gbWVkaXVtIHNpemUsIG1lZGl1bSBUVExcbiAgZXhwZWN0ZWRNb3ZlOiBuZXcgUXVhbnRpdkxSVUNhY2hlKCdleHBlY3RlZC1tb3ZlJywge1xuICAgIG1heFNpemU6IDE1MCxcbiAgICB0dGxNczogOTAgKiAxMDAwLCAvLyAxLjUgbWludXRlc1xuICAgIHVwZGF0ZUFnZU9uR2V0OiB0cnVlXG4gIH0pLFxuXG4gIC8vIEVhcm5pbmdzIGRhdGEgY2FjaGUgLSBzbWFsbGVyIHNpemUsIGxvbmdlciBUVExcbiAgZWFybmluZ3M6IG5ldyBRdWFudGl2TFJVQ2FjaGUoJ2Vhcm5pbmdzJywge1xuICAgIG1heFNpemU6IDEwMCxcbiAgICB0dGxNczogMzAwICogMTAwMCwgLy8gNSBtaW51dGVzXG4gICAgdXBkYXRlQWdlT25HZXQ6IHRydWVcbiAgfSksXG5cbiAgLy8gUHJpY2UgaGlzdG9yeSBjYWNoZSAtIHNtYWxsZXIgc2l6ZSwgbG9uZ2VyIFRUTFxuICBwcmljZUhpc3Rvcnk6IG5ldyBRdWFudGl2TFJVQ2FjaGUoJ3ByaWNlLWhpc3RvcnknLCB7XG4gICAgbWF4U2l6ZTogNTAsXG4gICAgdHRsTXM6IDYwMCAqIDEwMDAsIC8vIDEwIG1pbnV0ZXNcbiAgICB1cGRhdGVBZ2VPbkdldDogZmFsc2UgLy8gRG9uJ3QgdXBkYXRlIGFnZSBmb3IgaGlzdG9yaWNhbCBkYXRhXG4gIH0pLFxuXG4gIC8vIElWIHNlcmllcyBjYWNoZSAtIG1lZGl1bSBzaXplLCBsb25nZXIgVFRMXG4gIGl2U2VyaWVzOiBuZXcgUXVhbnRpdkxSVUNhY2hlKCdpdi1zZXJpZXMnLCB7XG4gICAgbWF4U2l6ZTogMTAwLFxuICAgIHR0bE1zOiAxODAwICogMTAwMCwgLy8gMzAgbWludXRlc1xuICAgIHVwZGF0ZUFnZU9uR2V0OiBmYWxzZVxuICB9KVxufTtcblxuLyoqXG4gKiBHZXQgYWxsIGNhY2hlIHN0YXRpc3RpY3MgZm9yIG1vbml0b3JpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENhY2hlU3RhdHMoKTogUmVjb3JkPHN0cmluZywgUmV0dXJuVHlwZTxRdWFudGl2TFJVQ2FjaGU8YW55PlsnZ2V0U3RhdHMnXT4+IHtcbiAgcmV0dXJuIHtcbiAgICBvcHRpb25zQ2hhaW46IENhY2hlSW5zdGFuY2VzLm9wdGlvbnNDaGFpbi5nZXRTdGF0cygpLFxuICAgIGV4cGVjdGVkTW92ZTogQ2FjaGVJbnN0YW5jZXMuZXhwZWN0ZWRNb3ZlLmdldFN0YXRzKCksXG4gICAgZWFybmluZ3M6IENhY2hlSW5zdGFuY2VzLmVhcm5pbmdzLmdldFN0YXRzKCksXG4gICAgcHJpY2VIaXN0b3J5OiBDYWNoZUluc3RhbmNlcy5wcmljZUhpc3RvcnkuZ2V0U3RhdHMoKSxcbiAgICBpdlNlcmllczogQ2FjaGVJbnN0YW5jZXMuaXZTZXJpZXMuZ2V0U3RhdHMoKVxuICB9O1xufVxuXG4vKipcbiAqIENsZWFyIGFsbCBjYWNoZXMgKHVzZWZ1bCBmb3IgdGVzdGluZyBvciBtYW51YWwgY2FjaGUgaW52YWxpZGF0aW9uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJBbGxDYWNoZXMoKTogdm9pZCB7XG4gIE9iamVjdC52YWx1ZXMoQ2FjaGVJbnN0YW5jZXMpLmZvckVhY2goY2FjaGUgPT4gY2FjaGUuY2xlYXIoKSk7XG59XG5cbi8qKlxuICogVXRpbGl0eSB0byBnZW5lcmF0ZSBjYWNoZSBrZXlzIGZvciBkaWZmZXJlbnQgZGF0YSB0eXBlc1xuICovXG5leHBvcnQgY29uc3QgQ2FjaGVLZXlzID0ge1xuICBvcHRpb25zQ2hhaW46IChzeW1ib2w6IHN0cmluZywgZXhwaXJ5OiBzdHJpbmcpID0+IGAke3N5bWJvbC50b1VwcGVyQ2FzZSgpfToke2V4cGlyeX1gLFxuICBleHBlY3RlZE1vdmU6IChzeW1ib2w6IHN0cmluZywgZXhwaXJ5OiBzdHJpbmcpID0+IGAke3N5bWJvbC50b1VwcGVyQ2FzZSgpfToke2V4cGlyeX1gLFxuICBlYXJuaW5nczogKHN5bWJvbDogc3RyaW5nKSA9PiBzeW1ib2wudG9VcHBlckNhc2UoKSxcbiAgcHJpY2VIaXN0b3J5OiAoc3ltYm9sOiBzdHJpbmcsIGRheXM6IG51bWJlcikgPT4gYCR7c3ltYm9sLnRvVXBwZXJDYXNlKCl9OiR7ZGF5c31kYCxcbiAgaXZTZXJpZXM6IChzeW1ib2w6IHN0cmluZywgZGF5czogbnVtYmVyKSA9PiBgJHtzeW1ib2wudG9VcHBlckNhc2UoKX06JHtkYXlzfWRgXG59O1xuIl0sIm5hbWVzIjpbIkxSVUNhY2hlIiwiUXVhbnRpdkxSVUNhY2hlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwib3B0aW9ucyIsImhpdHMiLCJtaXNzZXMiLCJjYWNoZSIsIm1heCIsIm1heFNpemUiLCJ0dGwiLCJ0dGxNcyIsInVwZGF0ZUFnZU9uR2V0IiwiZGlzcG9zZSIsInZhbHVlIiwia2V5IiwiY29uc29sZSIsImRlYnVnIiwiZ2V0IiwiZW50cnkiLCJkYXRhIiwic2V0IiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsImhhcyIsImRlbGV0ZSIsImNsZWFyIiwiZ2V0U3RhdHMiLCJ0b3RhbCIsInNpemUiLCJoaXRSYXRlIiwiY2FsY3VsYXRlZFNpemUiLCJnZXRPclNldCIsImZldGNoRm4iLCJjYWNoZWQiLCJlcnJvciIsInBlZWsiLCJrZXlzIiwiQXJyYXkiLCJmcm9tIiwiZ2V0SW5mbyIsImVudHJpZXMiLCJjYWNoZUVudHJpZXMiLCJwdXNoIiwiYWdlIiwic3RhdHMiLCJDYWNoZUluc3RhbmNlcyIsIm9wdGlvbnNDaGFpbiIsImV4cGVjdGVkTW92ZSIsImVhcm5pbmdzIiwicHJpY2VIaXN0b3J5IiwiaXZTZXJpZXMiLCJnZXRBbGxDYWNoZVN0YXRzIiwiY2xlYXJBbGxDYWNoZXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwiQ2FjaGVLZXlzIiwic3ltYm9sIiwiZXhwaXJ5IiwidG9VcHBlckNhc2UiLCJkYXlzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/cache/lru.ts\n");

/***/ }),

/***/ "(rsc)/./lib/cache/redis.ts":
/*!****************************!*\
  !*** ./lib/cache/redis.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keys: () => (/* binding */ Keys),\n/* harmony export */   QuantivCache: () => (/* binding */ QuantivCache),\n/* harmony export */   RedisCache: () => (/* binding */ RedisCache),\n/* harmony export */   checkRedisHealth: () => (/* binding */ checkRedisHealth),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   formatDateForKey: () => (/* binding */ formatDateForKey)\n/* harmony export */ });\n/* harmony import */ var _upstash_redis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @upstash/redis */ \"(rsc)/./node_modules/@upstash/redis/nodejs.mjs\");\n/**\n * Redis Client Wrapper for Upstash\n * Provides caching utilities and key builders for Quantiv\n */ \n// Initialize Redis client - disabled for development\nconst redis = process.env.REDIS_URL && process.env.REDIS_TOKEN ? new _upstash_redis__WEBPACK_IMPORTED_MODULE_0__.Redis({\n    url: process.env.REDIS_URL,\n    token: process.env.REDIS_TOKEN\n}) : null;\n/**\n * Redis key builders following Quantiv's naming convention\n */ const Keys = {\n    // Expected move snapshot: em:snap:${symbol}:${expiry}\n    expectedMoveSnapshot: (symbol, expiry)=>`em:snap:${symbol.toUpperCase()}:${expiry}`,\n    // Top movers for a date: em:top:${YYYYMMDD}\n    topMovers: (date)=>`em:top:${date}`,\n    // IV series for a symbol: iv:series:${symbol}\n    ivSeries: (symbol)=>`iv:series:${symbol.toUpperCase()}`,\n    // Daily visitor count: d:visits:${YYYYMMDD}\n    dailyVisits: (date)=>`d:visits:${date}`,\n    // Options chain cache: chain:${symbol}:${expiry}\n    optionsChain: (symbol, expiry)=>`chain:${symbol.toUpperCase()}:${expiry}`,\n    // Earnings data: earnings:${symbol}\n    earnings: (symbol)=>`earnings:${symbol.toUpperCase()}`,\n    // Price history: prices:${symbol}\n    priceHistory: (symbol)=>`prices:${symbol.toUpperCase()}`\n};\n/**\n * Generic JSON cache operations\n */ class RedisCache {\n    /**\n   * Set JSON data with TTL\n   */ static async setJson(key, data, ttlSeconds = 120) {\n        if (!redis) return; // Skip if Redis not configured\n        try {\n            await redis.setex(key, ttlSeconds, JSON.stringify(data));\n        } catch (error) {\n            console.error(`Redis setJson error for key ${key}:`, error);\n        // Don't throw - degrade gracefully without cache\n        }\n    }\n    /**\n   * Get JSON data\n   */ static async getJson(key) {\n        if (!redis) return null; // Skip if Redis not configured\n        try {\n            const result = await redis.get(key);\n            return result ? JSON.parse(result) : null;\n        } catch (error) {\n            console.error(`Redis getJson error for key ${key}:`, error);\n            return null; // Degrade gracefully\n        }\n    }\n    /**\n   * Increment counter and return new value\n   */ static async increment(key, ttlSeconds) {\n        if (!redis) return 1; // Return 1 if Redis not configured\n        try {\n            const newValue = await redis.incr(key);\n            if (ttlSeconds && newValue === 1) {\n                // Set TTL only on first increment (when key is created)\n                await redis.expire(key, ttlSeconds);\n            }\n            return newValue;\n        } catch (error) {\n            console.error(`Redis increment error for key ${key}:`, error);\n            return 0; // Return 0 on error\n        }\n    }\n    /**\n   * Add to sorted set (for top movers)\n   */ static async addToSortedSet(key, score, member, ttlSeconds) {\n        if (!redis) return; // Skip if Redis not configured\n        try {\n            await redis.zadd(key, {\n                score,\n                member\n            });\n            if (ttlSeconds) {\n                await redis.expire(key, ttlSeconds);\n            }\n        } catch (error) {\n            console.error(`Redis zadd error for key ${key}:`, error);\n        // Don't throw - degrade gracefully\n        }\n    }\n    /**\n   * Get top N members from sorted set (descending order)\n   */ static async getTopFromSortedSet(key, count = 10) {\n        if (!redis) return []; // Return empty array if Redis not configured\n        try {\n            const result = await redis.zrange(key, 0, count - 1, {\n                rev: true,\n                withScores: true\n            });\n            // Convert flat array to objects\n            const items = [];\n            for(let i = 0; i < result.length; i += 2){\n                items.push({\n                    member: result[i],\n                    score: result[i + 1]\n                });\n            }\n            return items;\n        } catch (error) {\n            console.error(`Redis zrange error for key ${key}:`, error);\n            return []; // Return empty array on error\n        }\n    }\n    /**\n   * Delete a key\n   */ static async delete(key) {\n        if (!redis) return; // Skip if Redis not configured\n        try {\n            await redis.del(key);\n        } catch (error) {\n            console.error(`Redis delete error for key ${key}:`, error);\n        // Don't throw - degrade gracefully\n        }\n    }\n    /**\n   * Check if key exists\n   */ static async exists(key) {\n        if (!redis) return false; // Return false if Redis not configured\n        try {\n            const result = await redis.exists(key);\n            return result === 1;\n        } catch (error) {\n            console.error(`Redis exists error for key ${key}:`, error);\n            return false;\n        }\n    }\n    /**\n   * Get TTL for a key\n   */ static async getTTL(key) {\n        if (!redis) return -1; // Return -1 if Redis not configured\n        try {\n            return await redis.ttl(key);\n        } catch (error) {\n            console.error(`Redis TTL error for key ${key}:`, error);\n            return -1;\n        }\n    }\n}\n/**\n * Specialized cache operations for Quantiv\n */ class QuantivCache {\n    /**\n   * Cache expected move snapshot\n   */ static async cacheExpectedMove(symbol, expiry, data, ttlSeconds = 120) {\n        const key = Keys.expectedMoveSnapshot(symbol, expiry);\n        const snapshot = {\n            ...data,\n            timestamp: new Date().toISOString(),\n            symbol: symbol.toUpperCase(),\n            expiry\n        };\n        await RedisCache.setJson(key, snapshot, ttlSeconds);\n    }\n    /**\n   * Get cached expected move\n   */ static async getExpectedMove(symbol, expiry) {\n        const key = Keys.expectedMoveSnapshot(symbol, expiry);\n        return await RedisCache.getJson(key);\n    }\n    /**\n   * Increment daily visitor count\n   */ static async incrementVisitorCount() {\n        const today = new Date().toISOString().split(\"T\")[0].replace(/-/g, \"\");\n        const key = Keys.dailyVisits(today);\n        // Set TTL to 48 hours (keep yesterday's count available)\n        return await RedisCache.increment(key, 48 * 60 * 60);\n    }\n    /**\n   * Get daily visitor count\n   */ static async getVisitorCount(date) {\n        const targetDate = date || new Date().toISOString().split(\"T\")[0].replace(/-/g, \"\");\n        const key = Keys.dailyVisits(targetDate);\n        if (!redis) return 0; // Return 0 if Redis not configured\n        try {\n            const count = await redis.get(key);\n            return count ? parseInt(count, 10) : 0;\n        } catch (error) {\n            console.error(`Error getting visitor count for ${targetDate}:`, error);\n            return 0;\n        }\n    }\n    /**\n   * Cache IV series data\n   */ static async cacheIVSeries(symbol, data, ttlSeconds = 24 * 60 * 60) {\n        const key = Keys.ivSeries(symbol);\n        await RedisCache.setJson(key, data, ttlSeconds);\n    }\n    /**\n   * Get cached IV series\n   */ static async getIVSeries(symbol) {\n        const key = Keys.ivSeries(symbol);\n        return await RedisCache.getJson(key);\n    }\n    /**\n   * Add symbol to top movers for a date\n   */ static async addTopMover(symbol, expectedMovePct, date) {\n        const targetDate = date || new Date().toISOString().split(\"T\")[0].replace(/-/g, \"\");\n        const key = Keys.topMovers(targetDate);\n        await RedisCache.addToSortedSet(key, expectedMovePct, symbol.toUpperCase(), 24 * 60 * 60 // 24 hour TTL\n        );\n    }\n    /**\n   * Get top movers for a date\n   */ static async getTopMovers(date, count = 10) {\n        const targetDate = date || new Date().toISOString().split(\"T\")[0].replace(/-/g, \"\");\n        const key = Keys.topMovers(targetDate);\n        const result = await RedisCache.getTopFromSortedSet(key, count);\n        return result.map((item)=>({\n                symbol: item.member,\n                expectedMovePct: item.score\n            }));\n    }\n}\n/**\n * Health check for Redis connection\n */ async function checkRedisHealth() {\n    if (!redis) {\n        return {\n            connected: false,\n            error: \"Redis not configured (missing REDIS_URL or REDIS_TOKEN)\"\n        };\n    }\n    try {\n        const start = Date.now();\n        await redis.ping();\n        const latency = Date.now() - start;\n        return {\n            connected: true,\n            latency\n        };\n    } catch (error) {\n        return {\n            connected: false,\n            error: error instanceof Error ? error.message : \"Unknown error\"\n        };\n    }\n}\n/**\n * Utility to format date for Redis keys\n */ function formatDateForKey(date = new Date()) {\n    return date.toISOString().split(\"T\")[0].replace(/-/g, \"\");\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (redis);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTs7Q0FFQyxHQUNNLGVBQWVzQztJQUtwQixJQUFJLENBQUM1RSxPQUFPO1FBQ1YsT0FBTztZQUNMNkUsV0FBVztZQUNYbEQsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJO1FBQ0YsTUFBTW1ELFFBQVFuQixLQUFLb0IsR0FBRztRQUN0QixNQUFNL0UsTUFBTWdGLElBQUk7UUFDaEIsTUFBTUMsVUFBVXRCLEtBQUtvQixHQUFHLEtBQUtEO1FBRTdCLE9BQU87WUFDTEQsV0FBVztZQUNYSTtRQUNGO0lBQ0YsRUFBRSxPQUFPdEQsT0FBTztRQUNkLE9BQU87WUFDTGtELFdBQVc7WUFDWGxELE9BQU9BLGlCQUFpQnVELFFBQVF2RCxNQUFNd0QsT0FBTyxHQUFHO1FBQ2xEO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0MsaUJBQWlCdkUsT0FBYSxJQUFJOEMsTUFBTTtJQUN0RCxPQUFPOUMsS0FBSytDLFdBQVcsR0FBR0ksS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUNDLE9BQU8sQ0FBQyxNQUFNO0FBQ3hEO0FBRUEsaUVBQWVqRSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbnRpdi8uL2xpYi9jYWNoZS9yZWRpcy50cz8xNzBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVkaXMgQ2xpZW50IFdyYXBwZXIgZm9yIFVwc3Rhc2hcbiAqIFByb3ZpZGVzIGNhY2hpbmcgdXRpbGl0aWVzIGFuZCBrZXkgYnVpbGRlcnMgZm9yIFF1YW50aXZcbiAqL1xuXG5pbXBvcnQgeyBSZWRpcyB9IGZyb20gJ0B1cHN0YXNoL3JlZGlzJztcblxuLy8gSW5pdGlhbGl6ZSBSZWRpcyBjbGllbnQgLSBkaXNhYmxlZCBmb3IgZGV2ZWxvcG1lbnRcbmNvbnN0IHJlZGlzID0gcHJvY2Vzcy5lbnYuUkVESVNfVVJMICYmIHByb2Nlc3MuZW52LlJFRElTX1RPS0VOIFxuICA/IG5ldyBSZWRpcyh7XG4gICAgICB1cmw6IHByb2Nlc3MuZW52LlJFRElTX1VSTCxcbiAgICAgIHRva2VuOiBwcm9jZXNzLmVudi5SRURJU19UT0tFTixcbiAgICB9KVxuICA6IG51bGw7XG5cbi8qKlxuICogUmVkaXMga2V5IGJ1aWxkZXJzIGZvbGxvd2luZyBRdWFudGl2J3MgbmFtaW5nIGNvbnZlbnRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IEtleXMgPSB7XG4gIC8vIEV4cGVjdGVkIG1vdmUgc25hcHNob3Q6IGVtOnNuYXA6JHtzeW1ib2x9OiR7ZXhwaXJ5fVxuICBleHBlY3RlZE1vdmVTbmFwc2hvdDogKHN5bWJvbDogc3RyaW5nLCBleHBpcnk6IHN0cmluZykgPT4gXG4gICAgYGVtOnNuYXA6JHtzeW1ib2wudG9VcHBlckNhc2UoKX06JHtleHBpcnl9YCxcbiAgXG4gIC8vIFRvcCBtb3ZlcnMgZm9yIGEgZGF0ZTogZW06dG9wOiR7WVlZWU1NRER9XG4gIHRvcE1vdmVyczogKGRhdGU6IHN0cmluZykgPT4gXG4gICAgYGVtOnRvcDoke2RhdGV9YCxcbiAgXG4gIC8vIElWIHNlcmllcyBmb3IgYSBzeW1ib2w6IGl2OnNlcmllczoke3N5bWJvbH1cbiAgaXZTZXJpZXM6IChzeW1ib2w6IHN0cmluZykgPT4gXG4gICAgYGl2OnNlcmllczoke3N5bWJvbC50b1VwcGVyQ2FzZSgpfWAsXG4gIFxuICAvLyBEYWlseSB2aXNpdG9yIGNvdW50OiBkOnZpc2l0czoke1lZWVlNTUREfVxuICBkYWlseVZpc2l0czogKGRhdGU6IHN0cmluZykgPT4gXG4gICAgYGQ6dmlzaXRzOiR7ZGF0ZX1gLFxuICBcbiAgLy8gT3B0aW9ucyBjaGFpbiBjYWNoZTogY2hhaW46JHtzeW1ib2x9OiR7ZXhwaXJ5fVxuICBvcHRpb25zQ2hhaW46IChzeW1ib2w6IHN0cmluZywgZXhwaXJ5OiBzdHJpbmcpID0+IFxuICAgIGBjaGFpbjoke3N5bWJvbC50b1VwcGVyQ2FzZSgpfToke2V4cGlyeX1gLFxuICBcbiAgLy8gRWFybmluZ3MgZGF0YTogZWFybmluZ3M6JHtzeW1ib2x9XG4gIGVhcm5pbmdzOiAoc3ltYm9sOiBzdHJpbmcpID0+IFxuICAgIGBlYXJuaW5nczoke3N5bWJvbC50b1VwcGVyQ2FzZSgpfWAsXG4gIFxuICAvLyBQcmljZSBoaXN0b3J5OiBwcmljZXM6JHtzeW1ib2x9XG4gIHByaWNlSGlzdG9yeTogKHN5bWJvbDogc3RyaW5nKSA9PiBcbiAgICBgcHJpY2VzOiR7c3ltYm9sLnRvVXBwZXJDYXNlKCl9YCxcbn07XG5cbi8qKlxuICogR2VuZXJpYyBKU09OIGNhY2hlIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFJlZGlzQ2FjaGUge1xuICAvKipcbiAgICogU2V0IEpTT04gZGF0YSB3aXRoIFRUTFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNldEpzb248VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQsIHR0bFNlY29uZHM6IG51bWJlciA9IDEyMCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghcmVkaXMpIHJldHVybjsgLy8gU2tpcCBpZiBSZWRpcyBub3QgY29uZmlndXJlZFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZWRpcy5zZXRleChrZXksIHR0bFNlY29uZHMsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUmVkaXMgc2V0SnNvbiBlcnJvciBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyAtIGRlZ3JhZGUgZ3JhY2VmdWxseSB3aXRob3V0IGNhY2hlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBKU09OIGRhdGFcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRKc29uPFQ+KGtleTogc3RyaW5nKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICAgIGlmICghcmVkaXMpIHJldHVybiBudWxsOyAvLyBTa2lwIGlmIFJlZGlzIG5vdCBjb25maWd1cmVkXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZGlzLmdldChrZXkpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA/IEpTT04ucGFyc2UocmVzdWx0IGFzIHN0cmluZykgOiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBSZWRpcyBnZXRKc29uIGVycm9yIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsOyAvLyBEZWdyYWRlIGdyYWNlZnVsbHlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IGNvdW50ZXIgYW5kIHJldHVybiBuZXcgdmFsdWVcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpbmNyZW1lbnQoa2V5OiBzdHJpbmcsIHR0bFNlY29uZHM/OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGlmICghcmVkaXMpIHJldHVybiAxOyAvLyBSZXR1cm4gMSBpZiBSZWRpcyBub3QgY29uZmlndXJlZFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGF3YWl0IHJlZGlzLmluY3Ioa2V5KTtcbiAgICAgIFxuICAgICAgaWYgKHR0bFNlY29uZHMgJiYgbmV3VmFsdWUgPT09IDEpIHtcbiAgICAgICAgLy8gU2V0IFRUTCBvbmx5IG9uIGZpcnN0IGluY3JlbWVudCAod2hlbiBrZXkgaXMgY3JlYXRlZClcbiAgICAgICAgYXdhaXQgcmVkaXMuZXhwaXJlKGtleSwgdHRsU2Vjb25kcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUmVkaXMgaW5jcmVtZW50IGVycm9yIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiAwOyAvLyBSZXR1cm4gMCBvbiBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdG8gc29ydGVkIHNldCAoZm9yIHRvcCBtb3ZlcnMpXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgYWRkVG9Tb3J0ZWRTZXQoa2V5OiBzdHJpbmcsIHNjb3JlOiBudW1iZXIsIG1lbWJlcjogc3RyaW5nLCB0dGxTZWNvbmRzPzogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFyZWRpcykgcmV0dXJuOyAvLyBTa2lwIGlmIFJlZGlzIG5vdCBjb25maWd1cmVkXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJlZGlzLnphZGQoa2V5LCB7IHNjb3JlLCBtZW1iZXIgfSk7XG4gICAgICBcbiAgICAgIGlmICh0dGxTZWNvbmRzKSB7XG4gICAgICAgIGF3YWl0IHJlZGlzLmV4cGlyZShrZXksIHR0bFNlY29uZHMpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBSZWRpcyB6YWRkIGVycm9yIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IHRocm93IC0gZGVncmFkZSBncmFjZWZ1bGx5XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0b3AgTiBtZW1iZXJzIGZyb20gc29ydGVkIHNldCAoZGVzY2VuZGluZyBvcmRlcilcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRUb3BGcm9tU29ydGVkU2V0KGtleTogc3RyaW5nLCBjb3VudDogbnVtYmVyID0gMTApOiBQcm9taXNlPEFycmF5PHtcbiAgICBtZW1iZXI6IHN0cmluZztcbiAgICBzY29yZTogbnVtYmVyO1xuICB9Pj4ge1xuICAgIGlmICghcmVkaXMpIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGlmIFJlZGlzIG5vdCBjb25maWd1cmVkXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZGlzLnpyYW5nZShrZXksIDAsIGNvdW50IC0gMSwgeyBcbiAgICAgICAgcmV2OiB0cnVlLCBcbiAgICAgICAgd2l0aFNjb3JlczogdHJ1ZSBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IGZsYXQgYXJyYXkgdG8gb2JqZWN0c1xuICAgICAgY29uc3QgaXRlbXM6IEFycmF5PHsgbWVtYmVyOiBzdHJpbmc7IHNjb3JlOiBudW1iZXIgfT4gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIG1lbWJlcjogcmVzdWx0W2ldIGFzIHN0cmluZyxcbiAgICAgICAgICBzY29yZTogcmVzdWx0W2kgKyAxXSBhcyBudW1iZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUmVkaXMgenJhbmdlIGVycm9yIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IG9uIGVycm9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGtleVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghcmVkaXMpIHJldHVybjsgLy8gU2tpcCBpZiBSZWRpcyBub3QgY29uZmlndXJlZFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZWRpcy5kZWwoa2V5KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgUmVkaXMgZGVsZXRlIGVycm9yIGZvciBrZXkgJHtrZXl9OmAsIGVycm9yKTtcbiAgICAgIC8vIERvbid0IHRocm93IC0gZGVncmFkZSBncmFjZWZ1bGx5XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGtleSBleGlzdHNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBleGlzdHMoa2V5OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXJlZGlzKSByZXR1cm4gZmFsc2U7IC8vIFJldHVybiBmYWxzZSBpZiBSZWRpcyBub3QgY29uZmlndXJlZFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWRpcy5leGlzdHMoa2V5KTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IDE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFJlZGlzIGV4aXN0cyBlcnJvciBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUVEwgZm9yIGEga2V5XG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0VFRMKGtleTogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAoIXJlZGlzKSByZXR1cm4gLTE7IC8vIFJldHVybiAtMSBpZiBSZWRpcyBub3QgY29uZmlndXJlZFxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVkaXMudHRsKGtleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFJlZGlzIFRUTCBlcnJvciBmb3Iga2V5ICR7a2V5fTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU3BlY2lhbGl6ZWQgY2FjaGUgb3BlcmF0aW9ucyBmb3IgUXVhbnRpdlxuICovXG5leHBvcnQgY2xhc3MgUXVhbnRpdkNhY2hlIHtcbiAgLyoqXG4gICAqIENhY2hlIGV4cGVjdGVkIG1vdmUgc25hcHNob3RcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjYWNoZUV4cGVjdGVkTW92ZShcbiAgICBzeW1ib2w6IHN0cmluZywgXG4gICAgZXhwaXJ5OiBzdHJpbmcsIFxuICAgIGRhdGE6IGFueSwgXG4gICAgdHRsU2Vjb25kczogbnVtYmVyID0gMTIwXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGtleSA9IEtleXMuZXhwZWN0ZWRNb3ZlU25hcHNob3Qoc3ltYm9sLCBleHBpcnkpO1xuICAgIGNvbnN0IHNuYXBzaG90ID0ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgc3ltYm9sOiBzeW1ib2wudG9VcHBlckNhc2UoKSxcbiAgICAgIGV4cGlyeVxuICAgIH07XG4gICAgXG4gICAgYXdhaXQgUmVkaXNDYWNoZS5zZXRKc29uKGtleSwgc25hcHNob3QsIHR0bFNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZWQgZXhwZWN0ZWQgbW92ZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGdldEV4cGVjdGVkTW92ZShzeW1ib2w6IHN0cmluZywgZXhwaXJ5OiBzdHJpbmcpOiBQcm9taXNlPGFueSB8IG51bGw+IHtcbiAgICBjb25zdCBrZXkgPSBLZXlzLmV4cGVjdGVkTW92ZVNuYXBzaG90KHN5bWJvbCwgZXhwaXJ5KTtcbiAgICByZXR1cm4gYXdhaXQgUmVkaXNDYWNoZS5nZXRKc29uKGtleSk7XG4gIH1cblxuICAvKipcbiAgICogSW5jcmVtZW50IGRhaWx5IHZpc2l0b3IgY291bnRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBpbmNyZW1lbnRWaXNpdG9yQ291bnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIGNvbnN0IGtleSA9IEtleXMuZGFpbHlWaXNpdHModG9kYXkpO1xuICAgIFxuICAgIC8vIFNldCBUVEwgdG8gNDggaG91cnMgKGtlZXAgeWVzdGVyZGF5J3MgY291bnQgYXZhaWxhYmxlKVxuICAgIHJldHVybiBhd2FpdCBSZWRpc0NhY2hlLmluY3JlbWVudChrZXksIDQ4ICogNjAgKiA2MCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhaWx5IHZpc2l0b3IgY291bnRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRWaXNpdG9yQ291bnQoZGF0ZT86IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgdGFyZ2V0RGF0ZSA9IGRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0ucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgY29uc3Qga2V5ID0gS2V5cy5kYWlseVZpc2l0cyh0YXJnZXREYXRlKTtcbiAgICBcbiAgICBpZiAoIXJlZGlzKSByZXR1cm4gMDsgLy8gUmV0dXJuIDAgaWYgUmVkaXMgbm90IGNvbmZpZ3VyZWRcbiAgICB0cnkge1xuICAgICAgY29uc3QgY291bnQgPSBhd2FpdCByZWRpcy5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBjb3VudCA/IHBhcnNlSW50KGNvdW50IGFzIHN0cmluZywgMTApIDogMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZ2V0dGluZyB2aXNpdG9yIGNvdW50IGZvciAke3RhcmdldERhdGV9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWNoZSBJViBzZXJpZXMgZGF0YVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGNhY2hlSVZTZXJpZXMoc3ltYm9sOiBzdHJpbmcsIGRhdGE6IGFueVtdLCB0dGxTZWNvbmRzOiBudW1iZXIgPSAyNCAqIDYwICogNjApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBrZXkgPSBLZXlzLml2U2VyaWVzKHN5bWJvbCk7XG4gICAgYXdhaXQgUmVkaXNDYWNoZS5zZXRKc29uKGtleSwgZGF0YSwgdHRsU2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNhY2hlZCBJViBzZXJpZXNcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRJVlNlcmllcyhzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8YW55W10gfCBudWxsPiB7XG4gICAgY29uc3Qga2V5ID0gS2V5cy5pdlNlcmllcyhzeW1ib2wpO1xuICAgIHJldHVybiBhd2FpdCBSZWRpc0NhY2hlLmdldEpzb24oa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgc3ltYm9sIHRvIHRvcCBtb3ZlcnMgZm9yIGEgZGF0ZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGFkZFRvcE1vdmVyKFxuICAgIHN5bWJvbDogc3RyaW5nLCBcbiAgICBleHBlY3RlZE1vdmVQY3Q6IG51bWJlciwgXG4gICAgZGF0ZT86IHN0cmluZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB0YXJnZXREYXRlID0gZGF0ZSB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXS5yZXBsYWNlKC8tL2csICcnKTtcbiAgICBjb25zdCBrZXkgPSBLZXlzLnRvcE1vdmVycyh0YXJnZXREYXRlKTtcbiAgICBcbiAgICBhd2FpdCBSZWRpc0NhY2hlLmFkZFRvU29ydGVkU2V0KFxuICAgICAga2V5LCBcbiAgICAgIGV4cGVjdGVkTW92ZVBjdCwgXG4gICAgICBzeW1ib2wudG9VcHBlckNhc2UoKSwgXG4gICAgICAyNCAqIDYwICogNjAgLy8gMjQgaG91ciBUVExcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0b3AgbW92ZXJzIGZvciBhIGRhdGVcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRUb3BNb3ZlcnMoZGF0ZT86IHN0cmluZywgY291bnQ6IG51bWJlciA9IDEwKTogUHJvbWlzZTxBcnJheTx7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgZXhwZWN0ZWRNb3ZlUGN0OiBudW1iZXI7XG4gIH0+PiB7XG4gICAgY29uc3QgdGFyZ2V0RGF0ZSA9IGRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0ucmVwbGFjZSgvLS9nLCAnJyk7XG4gICAgY29uc3Qga2V5ID0gS2V5cy50b3BNb3ZlcnModGFyZ2V0RGF0ZSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVkaXNDYWNoZS5nZXRUb3BGcm9tU29ydGVkU2V0KGtleSwgY291bnQpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQubWFwKGl0ZW0gPT4gKHtcbiAgICAgIHN5bWJvbDogaXRlbS5tZW1iZXIsXG4gICAgICBleHBlY3RlZE1vdmVQY3Q6IGl0ZW0uc2NvcmVcbiAgICB9KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWFsdGggY2hlY2sgZm9yIFJlZGlzIGNvbm5lY3Rpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVkaXNIZWFsdGgoKTogUHJvbWlzZTx7XG4gIGNvbm5lY3RlZDogYm9vbGVhbjtcbiAgbGF0ZW5jeT86IG51bWJlcjtcbiAgZXJyb3I/OiBzdHJpbmc7XG59PiB7XG4gIGlmICghcmVkaXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnUmVkaXMgbm90IGNvbmZpZ3VyZWQgKG1pc3NpbmcgUkVESVNfVVJMIG9yIFJFRElTX1RPS0VOKSdcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGF3YWl0IHJlZGlzLnBpbmcoKTtcbiAgICBjb25zdCBsYXRlbmN5ID0gRGF0ZS5ub3coKSAtIHN0YXJ0O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjb25uZWN0ZWQ6IHRydWUsXG4gICAgICBsYXRlbmN5XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IHRvIGZvcm1hdCBkYXRlIGZvciBSZWRpcyBrZXlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlRm9yS2V5KGRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpKTogc3RyaW5nIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLnJlcGxhY2UoLy0vZywgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZWRpcztcbiJdLCJuYW1lcyI6WyJSZWRpcyIsInJlZGlzIiwicHJvY2VzcyIsImVudiIsIlJFRElTX1VSTCIsIlJFRElTX1RPS0VOIiwidXJsIiwidG9rZW4iLCJLZXlzIiwiZXhwZWN0ZWRNb3ZlU25hcHNob3QiLCJzeW1ib2wiLCJleHBpcnkiLCJ0b1VwcGVyQ2FzZSIsInRvcE1vdmVycyIsImRhdGUiLCJpdlNlcmllcyIsImRhaWx5VmlzaXRzIiwib3B0aW9uc0NoYWluIiwiZWFybmluZ3MiLCJwcmljZUhpc3RvcnkiLCJSZWRpc0NhY2hlIiwic2V0SnNvbiIsImtleSIsImRhdGEiLCJ0dGxTZWNvbmRzIiwic2V0ZXgiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0SnNvbiIsInJlc3VsdCIsImdldCIsInBhcnNlIiwiaW5jcmVtZW50IiwibmV3VmFsdWUiLCJpbmNyIiwiZXhwaXJlIiwiYWRkVG9Tb3J0ZWRTZXQiLCJzY29yZSIsIm1lbWJlciIsInphZGQiLCJnZXRUb3BGcm9tU29ydGVkU2V0IiwiY291bnQiLCJ6cmFuZ2UiLCJyZXYiLCJ3aXRoU2NvcmVzIiwiaXRlbXMiLCJpIiwibGVuZ3RoIiwicHVzaCIsImRlbGV0ZSIsImRlbCIsImV4aXN0cyIsImdldFRUTCIsInR0bCIsIlF1YW50aXZDYWNoZSIsImNhY2hlRXhwZWN0ZWRNb3ZlIiwic25hcHNob3QiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJnZXRFeHBlY3RlZE1vdmUiLCJpbmNyZW1lbnRWaXNpdG9yQ291bnQiLCJ0b2RheSIsInNwbGl0IiwicmVwbGFjZSIsImdldFZpc2l0b3JDb3VudCIsInRhcmdldERhdGUiLCJwYXJzZUludCIsImNhY2hlSVZTZXJpZXMiLCJnZXRJVlNlcmllcyIsImFkZFRvcE1vdmVyIiwiZXhwZWN0ZWRNb3ZlUGN0IiwiZ2V0VG9wTW92ZXJzIiwibWFwIiwiaXRlbSIsImNoZWNrUmVkaXNIZWFsdGgiLCJjb25uZWN0ZWQiLCJzdGFydCIsIm5vdyIsInBpbmciLCJsYXRlbmN5IiwiRXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0RGF0ZUZvcktleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/cache/redis.ts\n");

/***/ }),

/***/ "(rsc)/./lib/pricing/blackScholes.ts":
/*!*************************************!*\
  !*** ./lib/pricing/blackScholes.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   blackScholes: () => (/* binding */ blackScholes),\n/* harmony export */   findATMStrike: () => (/* binding */ findATMStrike),\n/* harmony export */   impliedVolBrent: () => (/* binding */ impliedVolBrent)\n/* harmony export */ });\n/**\n * Black-Scholes pricing model with Greeks calculation\n * Used for options pricing and implied volatility calculations\n */ /**\n * Standard normal cumulative distribution function\n */ function normCDF(x) {\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x) / Math.sqrt(2.0);\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n    return 0.5 * (1.0 + sign * y);\n}\n/**\n * Standard normal probability density function\n */ function normPDF(x) {\n    return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);\n}\n/**\n * Calculate d1 and d2 parameters for Black-Scholes\n */ function calculateD1D2(params) {\n    const { S, K, T, r, q, iv } = params;\n    if (T <= 0 || iv <= 0) {\n        throw new Error(\"Time to expiration and volatility must be positive\");\n    }\n    const d1 = (Math.log(S / K) + (r - q + 0.5 * iv * iv) * T) / (iv * Math.sqrt(T));\n    const d2 = d1 - iv * Math.sqrt(T);\n    return {\n        d1,\n        d2\n    };\n}\n/**\n * Calculate Black-Scholes option prices and Greeks\n */ function blackScholes(params) {\n    const { S, K, T, r, q } = params;\n    if (S <= 0 || K <= 0) {\n        throw new Error(\"Stock price and strike price must be positive\");\n    }\n    const { d1, d2 } = calculateD1D2(params);\n    const Nd1 = normCDF(d1);\n    const Nd2 = normCDF(d2);\n    const NegD1 = normCDF(-d1);\n    const NegD2 = normCDF(-d2);\n    const nd1 = normPDF(d1);\n    const discountFactor = Math.exp(-r * T);\n    const dividendFactor = Math.exp(-q * T);\n    // Option prices\n    const call = S * dividendFactor * Nd1 - K * discountFactor * Nd2;\n    const put = K * discountFactor * NegD2 - S * dividendFactor * NegD1;\n    // Greeks\n    const delta = {\n        call: dividendFactor * Nd1,\n        put: -dividendFactor * NegD1\n    };\n    const gamma = dividendFactor * nd1 / (S * params.iv * Math.sqrt(T));\n    const theta = {\n        call: (-S * dividendFactor * nd1 * params.iv / (2 * Math.sqrt(T)) - r * K * discountFactor * Nd2 + q * S * dividendFactor * Nd1) / 365,\n        put: (-S * dividendFactor * nd1 * params.iv / (2 * Math.sqrt(T)) + r * K * discountFactor * NegD2 - q * S * dividendFactor * NegD1) / 365\n    };\n    const vega = S * dividendFactor * nd1 * Math.sqrt(T) / 100;\n    const rho = {\n        call: K * T * discountFactor * Nd2 / 100,\n        put: -K * T * discountFactor * NegD2 / 100\n    };\n    return {\n        call: Math.max(0, call),\n        put: Math.max(0, put),\n        delta,\n        gamma,\n        theta,\n        vega,\n        rho\n    };\n}\n/**\n * Calculate implied volatility using Brent's method\n */ function impliedVolBrent(marketPrice, params, isCall = true, tolerance = 1e-6, maxIterations = 100) {\n    if (marketPrice <= 0) {\n        throw new Error(\"Market price must be positive\");\n    }\n    const { S, K, T } = params;\n    // Intrinsic value bounds\n    const intrinsic = isCall ? Math.max(0, S - K) : Math.max(0, K - S);\n    if (marketPrice <= intrinsic) {\n        return 0.01; // Minimum volatility\n    }\n    // Initial bounds for volatility search\n    let volLow = 0.01;\n    let volHigh = 5.0;\n    // Test bounds\n    const testLow = blackScholes({\n        ...params,\n        iv: volLow\n    });\n    const testHigh = blackScholes({\n        ...params,\n        iv: volHigh\n    });\n    const priceLow = isCall ? testLow.call : testLow.put;\n    const priceHigh = isCall ? testHigh.call : testHigh.put;\n    if (marketPrice < priceLow) return volLow;\n    if (marketPrice > priceHigh) return volHigh;\n    // Brent's method\n    let a = volLow;\n    let b = volHigh;\n    let c = volHigh;\n    let fa = priceLow - marketPrice;\n    let fb = priceHigh - marketPrice;\n    let fc = fb;\n    for(let iter = 0; iter < maxIterations; iter++){\n        if (Math.abs(fb) < tolerance) {\n            return b;\n        }\n        if (Math.sign(fa) === Math.sign(fb)) {\n            a = c;\n            fa = fc;\n        }\n        if (Math.abs(fa) < Math.abs(fb)) {\n            [a, b] = [\n                b,\n                a\n            ];\n            [fa, fb] = [\n                fb,\n                fa\n            ];\n        }\n        const tol = 2 * tolerance * Math.abs(b) + tolerance;\n        const m = (a - b) / 2;\n        if (Math.abs(m) < tol) {\n            return b;\n        }\n        let p, q, r, s;\n        if (Math.abs(c - b) < tolerance || Math.abs(fc - fb) < tolerance) {\n            // Bisection\n            p = m;\n            q = 1;\n        } else {\n            // Inverse quadratic interpolation\n            s = fb / fc;\n            if (Math.abs(a - c) < tolerance) {\n                p = 2 * m * s;\n                q = 1 - s;\n            } else {\n                q = fc / fa;\n                r = fb / fa;\n                p = s * (2 * m * q * (q - r) - (b - c) * (r - 1));\n                q = (q - 1) * (r - 1) * (s - 1);\n            }\n        }\n        if (p > 0) q = -q;\n        else p = -p;\n        if (2 * p < Math.min(3 * m * q - Math.abs(tol * q), Math.abs((c - b) * q))) {\n            c = b;\n            fc = fb;\n            b += p / q;\n        } else {\n            c = b;\n            fc = fb;\n            b += m;\n        }\n        const bsResult = blackScholes({\n            ...params,\n            iv: b\n        });\n        fb = (isCall ? bsResult.call : bsResult.put) - marketPrice;\n    }\n    return b;\n}\n/**\n * Find at-the-money strike and calculate ATM implied volatility\n */ function findATMStrike(strikes, spot) {\n    if (strikes.length === 0) {\n        throw new Error(\"No strikes provided\");\n    }\n    return strikes.reduce((closest, strike)=>Math.abs(strike - spot) < Math.abs(closest - spot) ? strike : closest);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxLQUFLRDtZQUNMSCxLQUFLbkQsSUFBSWdCO1FBQ1gsT0FBTztZQUNMb0MsSUFBSUQ7WUFDSkksS0FBS0Q7WUFDTEgsS0FBS087UUFDUDtRQUVBLE1BQU1HLFdBQVd2QyxhQUFhO1lBQUUsR0FBR1gsTUFBTTtZQUFFTSxJQUFJa0M7UUFBRTtRQUNqREcsS0FBSyxDQUFDZCxTQUFTcUIsU0FBUy9CLElBQUksR0FBRytCLFNBQVM5QixHQUFHLElBQUlRO0lBQ2pEO0lBRUEsT0FBT1k7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU1csY0FBY0MsT0FBaUIsRUFBRUMsSUFBWTtJQUMzRCxJQUFJRCxRQUFRRSxNQUFNLEtBQUssR0FBRztRQUN4QixNQUFNLElBQUkvQyxNQUFNO0lBQ2xCO0lBRUEsT0FBTzZDLFFBQVFHLE1BQU0sQ0FBQyxDQUFDQyxTQUFTQyxTQUM5QmxFLEtBQUtDLEdBQUcsQ0FBQ2lFLFNBQVNKLFFBQVE5RCxLQUFLQyxHQUFHLENBQUNnRSxVQUFVSCxRQUFRSSxTQUFTRDtBQUVsRSIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YW50aXYvLi9saWIvcHJpY2luZy9ibGFja1NjaG9sZXMudHM/ZGM2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJsYWNrLVNjaG9sZXMgcHJpY2luZyBtb2RlbCB3aXRoIEdyZWVrcyBjYWxjdWxhdGlvblxuICogVXNlZCBmb3Igb3B0aW9ucyBwcmljaW5nIGFuZCBpbXBsaWVkIHZvbGF0aWxpdHkgY2FsY3VsYXRpb25zXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBCU1BhcmFtcyB7XG4gIFM6IG51bWJlcjsgIC8vIEN1cnJlbnQgc3RvY2sgcHJpY2VcbiAgSzogbnVtYmVyOyAgLy8gU3RyaWtlIHByaWNlXG4gIFQ6IG51bWJlcjsgIC8vIFRpbWUgdG8gZXhwaXJhdGlvbiAoaW4geWVhcnMpXG4gIHI6IG51bWJlcjsgIC8vIFJpc2stZnJlZSByYXRlXG4gIHE6IG51bWJlcjsgIC8vIERpdmlkZW5kIHlpZWxkIChjYXJyeSByYXRlKVxuICBpdjogbnVtYmVyOyAvLyBJbXBsaWVkIHZvbGF0aWxpdHlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCU1Jlc3VsdCB7XG4gIGNhbGw6IG51bWJlcjtcbiAgcHV0OiBudW1iZXI7XG4gIGRlbHRhOiB7IGNhbGw6IG51bWJlcjsgcHV0OiBudW1iZXIgfTtcbiAgZ2FtbWE6IG51bWJlcjtcbiAgdGhldGE6IHsgY2FsbDogbnVtYmVyOyBwdXQ6IG51bWJlciB9O1xuICB2ZWdhOiBudW1iZXI7XG4gIHJobzogeyBjYWxsOiBudW1iZXI7IHB1dDogbnVtYmVyIH07XG59XG5cbi8qKlxuICogU3RhbmRhcmQgbm9ybWFsIGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIG5vcm1DREYoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgYTEgPSAwLjI1NDgyOTU5MjtcbiAgY29uc3QgYTIgPSAtMC4yODQ0OTY3MzY7XG4gIGNvbnN0IGEzID0gMS40MjE0MTM3NDE7XG4gIGNvbnN0IGE0ID0gLTEuNDUzMTUyMDI3O1xuICBjb25zdCBhNSA9IDEuMDYxNDA1NDI5O1xuICBjb25zdCBwID0gMC4zMjc1OTExO1xuXG4gIGNvbnN0IHNpZ24gPSB4IDwgMCA/IC0xIDogMTtcbiAgeCA9IE1hdGguYWJzKHgpIC8gTWF0aC5zcXJ0KDIuMCk7XG5cbiAgY29uc3QgdCA9IDEuMCAvICgxLjAgKyBwICogeCk7XG4gIGNvbnN0IHkgPSAxLjAgLSAoKCgoKGE1ICogdCArIGE0KSAqIHQpICsgYTMpICogdCArIGEyKSAqIHQgKyBhMSkgKiB0ICogTWF0aC5leHAoLXggKiB4KTtcblxuICByZXR1cm4gMC41ICogKDEuMCArIHNpZ24gKiB5KTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZCBub3JtYWwgcHJvYmFiaWxpdHkgZGVuc2l0eSBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBub3JtUERGKHg6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBNYXRoLmV4cCgtMC41ICogeCAqIHgpIC8gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZDEgYW5kIGQyIHBhcmFtZXRlcnMgZm9yIEJsYWNrLVNjaG9sZXNcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRDFEMihwYXJhbXM6IEJTUGFyYW1zKTogeyBkMTogbnVtYmVyOyBkMjogbnVtYmVyIH0ge1xuICBjb25zdCB7IFMsIEssIFQsIHIsIHEsIGl2IH0gPSBwYXJhbXM7XG4gIFxuICBpZiAoVCA8PSAwIHx8IGl2IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWUgdG8gZXhwaXJhdGlvbiBhbmQgdm9sYXRpbGl0eSBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICBjb25zdCBkMSA9IChNYXRoLmxvZyhTIC8gSykgKyAociAtIHEgKyAwLjUgKiBpdiAqIGl2KSAqIFQpIC8gKGl2ICogTWF0aC5zcXJ0KFQpKTtcbiAgY29uc3QgZDIgPSBkMSAtIGl2ICogTWF0aC5zcXJ0KFQpO1xuXG4gIHJldHVybiB7IGQxLCBkMiB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBCbGFjay1TY2hvbGVzIG9wdGlvbiBwcmljZXMgYW5kIEdyZWVrc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYmxhY2tTY2hvbGVzKHBhcmFtczogQlNQYXJhbXMpOiBCU1Jlc3VsdCB7XG4gIGNvbnN0IHsgUywgSywgVCwgciwgcSB9ID0gcGFyYW1zO1xuICBcbiAgaWYgKFMgPD0gMCB8fCBLIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0b2NrIHByaWNlIGFuZCBzdHJpa2UgcHJpY2UgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgY29uc3QgeyBkMSwgZDIgfSA9IGNhbGN1bGF0ZUQxRDIocGFyYW1zKTtcbiAgXG4gIGNvbnN0IE5kMSA9IG5vcm1DREYoZDEpO1xuICBjb25zdCBOZDIgPSBub3JtQ0RGKGQyKTtcbiAgY29uc3QgTmVnRDEgPSBub3JtQ0RGKC1kMSk7XG4gIGNvbnN0IE5lZ0QyID0gbm9ybUNERigtZDIpO1xuICBjb25zdCBuZDEgPSBub3JtUERGKGQxKTtcblxuICBjb25zdCBkaXNjb3VudEZhY3RvciA9IE1hdGguZXhwKC1yICogVCk7XG4gIGNvbnN0IGRpdmlkZW5kRmFjdG9yID0gTWF0aC5leHAoLXEgKiBUKTtcblxuICAvLyBPcHRpb24gcHJpY2VzXG4gIGNvbnN0IGNhbGwgPSBTICogZGl2aWRlbmRGYWN0b3IgKiBOZDEgLSBLICogZGlzY291bnRGYWN0b3IgKiBOZDI7XG4gIGNvbnN0IHB1dCA9IEsgKiBkaXNjb3VudEZhY3RvciAqIE5lZ0QyIC0gUyAqIGRpdmlkZW5kRmFjdG9yICogTmVnRDE7XG5cbiAgLy8gR3JlZWtzXG4gIGNvbnN0IGRlbHRhID0ge1xuICAgIGNhbGw6IGRpdmlkZW5kRmFjdG9yICogTmQxLFxuICAgIHB1dDogLWRpdmlkZW5kRmFjdG9yICogTmVnRDFcbiAgfTtcblxuICBjb25zdCBnYW1tYSA9IChkaXZpZGVuZEZhY3RvciAqIG5kMSkgLyAoUyAqIHBhcmFtcy5pdiAqIE1hdGguc3FydChUKSk7XG4gIFxuICBjb25zdCB0aGV0YSA9IHtcbiAgICBjYWxsOiAoLVMgKiBkaXZpZGVuZEZhY3RvciAqIG5kMSAqIHBhcmFtcy5pdiAvICgyICogTWF0aC5zcXJ0KFQpKSBcbiAgICAgICAgICAgLSByICogSyAqIGRpc2NvdW50RmFjdG9yICogTmQyIFxuICAgICAgICAgICArIHEgKiBTICogZGl2aWRlbmRGYWN0b3IgKiBOZDEpIC8gMzY1LFxuICAgIHB1dDogKC1TICogZGl2aWRlbmRGYWN0b3IgKiBuZDEgKiBwYXJhbXMuaXYgLyAoMiAqIE1hdGguc3FydChUKSkgXG4gICAgICAgICAgKyByICogSyAqIGRpc2NvdW50RmFjdG9yICogTmVnRDIgXG4gICAgICAgICAgLSBxICogUyAqIGRpdmlkZW5kRmFjdG9yICogTmVnRDEpIC8gMzY1XG4gIH07XG5cbiAgY29uc3QgdmVnYSA9IChTICogZGl2aWRlbmRGYWN0b3IgKiBuZDEgKiBNYXRoLnNxcnQoVCkpIC8gMTAwO1xuXG4gIGNvbnN0IHJobyA9IHtcbiAgICBjYWxsOiAoSyAqIFQgKiBkaXNjb3VudEZhY3RvciAqIE5kMikgLyAxMDAsXG4gICAgcHV0OiAoLUsgKiBUICogZGlzY291bnRGYWN0b3IgKiBOZWdEMikgLyAxMDBcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNhbGw6IE1hdGgubWF4KDAsIGNhbGwpLFxuICAgIHB1dDogTWF0aC5tYXgoMCwgcHV0KSxcbiAgICBkZWx0YSxcbiAgICBnYW1tYSxcbiAgICB0aGV0YSxcbiAgICB2ZWdhLFxuICAgIHJob1xuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBpbXBsaWVkIHZvbGF0aWxpdHkgdXNpbmcgQnJlbnQncyBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcGxpZWRWb2xCcmVudChcbiAgbWFya2V0UHJpY2U6IG51bWJlcixcbiAgcGFyYW1zOiBPbWl0PEJTUGFyYW1zLCAnaXYnPixcbiAgaXNDYWxsOiBib29sZWFuID0gdHJ1ZSxcbiAgdG9sZXJhbmNlOiBudW1iZXIgPSAxZS02LFxuICBtYXhJdGVyYXRpb25zOiBudW1iZXIgPSAxMDBcbik6IG51bWJlciB7XG4gIGlmIChtYXJrZXRQcmljZSA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXJrZXQgcHJpY2UgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICB9XG5cbiAgY29uc3QgeyBTLCBLLCBUIH0gPSBwYXJhbXM7XG4gIFxuICAvLyBJbnRyaW5zaWMgdmFsdWUgYm91bmRzXG4gIGNvbnN0IGludHJpbnNpYyA9IGlzQ2FsbCA/IE1hdGgubWF4KDAsIFMgLSBLKSA6IE1hdGgubWF4KDAsIEsgLSBTKTtcbiAgaWYgKG1hcmtldFByaWNlIDw9IGludHJpbnNpYykge1xuICAgIHJldHVybiAwLjAxOyAvLyBNaW5pbXVtIHZvbGF0aWxpdHlcbiAgfVxuXG4gIC8vIEluaXRpYWwgYm91bmRzIGZvciB2b2xhdGlsaXR5IHNlYXJjaFxuICBsZXQgdm9sTG93ID0gMC4wMTtcbiAgbGV0IHZvbEhpZ2ggPSA1LjA7XG5cbiAgLy8gVGVzdCBib3VuZHNcbiAgY29uc3QgdGVzdExvdyA9IGJsYWNrU2Nob2xlcyh7IC4uLnBhcmFtcywgaXY6IHZvbExvdyB9KTtcbiAgY29uc3QgdGVzdEhpZ2ggPSBibGFja1NjaG9sZXMoeyAuLi5wYXJhbXMsIGl2OiB2b2xIaWdoIH0pO1xuICBcbiAgY29uc3QgcHJpY2VMb3cgPSBpc0NhbGwgPyB0ZXN0TG93LmNhbGwgOiB0ZXN0TG93LnB1dDtcbiAgY29uc3QgcHJpY2VIaWdoID0gaXNDYWxsID8gdGVzdEhpZ2guY2FsbCA6IHRlc3RIaWdoLnB1dDtcblxuICBpZiAobWFya2V0UHJpY2UgPCBwcmljZUxvdykgcmV0dXJuIHZvbExvdztcbiAgaWYgKG1hcmtldFByaWNlID4gcHJpY2VIaWdoKSByZXR1cm4gdm9sSGlnaDtcblxuICAvLyBCcmVudCdzIG1ldGhvZFxuICBsZXQgYSA9IHZvbExvdztcbiAgbGV0IGIgPSB2b2xIaWdoO1xuICBsZXQgYyA9IHZvbEhpZ2g7XG4gIFxuICBsZXQgZmEgPSBwcmljZUxvdyAtIG1hcmtldFByaWNlO1xuICBsZXQgZmIgPSBwcmljZUhpZ2ggLSBtYXJrZXRQcmljZTtcbiAgbGV0IGZjID0gZmI7XG5cbiAgZm9yIChsZXQgaXRlciA9IDA7IGl0ZXIgPCBtYXhJdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICBpZiAoTWF0aC5hYnMoZmIpIDwgdG9sZXJhbmNlKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5zaWduKGZhKSA9PT0gTWF0aC5zaWduKGZiKSkge1xuICAgICAgYSA9IGM7XG4gICAgICBmYSA9IGZjO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhmYSkgPCBNYXRoLmFicyhmYikpIHtcbiAgICAgIFthLCBiXSA9IFtiLCBhXTtcbiAgICAgIFtmYSwgZmJdID0gW2ZiLCBmYV07XG4gICAgfVxuXG4gICAgY29uc3QgdG9sID0gMiAqIHRvbGVyYW5jZSAqIE1hdGguYWJzKGIpICsgdG9sZXJhbmNlO1xuICAgIGNvbnN0IG0gPSAoYSAtIGIpIC8gMjtcblxuICAgIGlmIChNYXRoLmFicyhtKSA8IHRvbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgbGV0IHAsIHEsIHIsIHM7XG4gICAgaWYgKE1hdGguYWJzKGMgLSBiKSA8IHRvbGVyYW5jZSB8fCBNYXRoLmFicyhmYyAtIGZiKSA8IHRvbGVyYW5jZSkge1xuICAgICAgLy8gQmlzZWN0aW9uXG4gICAgICBwID0gbTtcbiAgICAgIHEgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnZlcnNlIHF1YWRyYXRpYyBpbnRlcnBvbGF0aW9uXG4gICAgICBzID0gZmIgLyBmYztcbiAgICAgIGlmIChNYXRoLmFicyhhIC0gYykgPCB0b2xlcmFuY2UpIHtcbiAgICAgICAgcCA9IDIgKiBtICogcztcbiAgICAgICAgcSA9IDEgLSBzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IGZjIC8gZmE7XG4gICAgICAgIHIgPSBmYiAvIGZhO1xuICAgICAgICBwID0gcyAqICgyICogbSAqIHEgKiAocSAtIHIpIC0gKGIgLSBjKSAqIChyIC0gMSkpO1xuICAgICAgICBxID0gKHEgLSAxKSAqIChyIC0gMSkgKiAocyAtIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwID4gMCkgcSA9IC1xO1xuICAgIGVsc2UgcCA9IC1wO1xuXG4gICAgaWYgKDIgKiBwIDwgTWF0aC5taW4oMyAqIG0gKiBxIC0gTWF0aC5hYnModG9sICogcSksIE1hdGguYWJzKChjIC0gYikgKiBxKSkpIHtcbiAgICAgIGMgPSBiO1xuICAgICAgZmMgPSBmYjtcbiAgICAgIGIgKz0gcCAvIHE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgPSBiO1xuICAgICAgZmMgPSBmYjtcbiAgICAgIGIgKz0gbTtcbiAgICB9XG5cbiAgICBjb25zdCBic1Jlc3VsdCA9IGJsYWNrU2Nob2xlcyh7IC4uLnBhcmFtcywgaXY6IGIgfSk7XG4gICAgZmIgPSAoaXNDYWxsID8gYnNSZXN1bHQuY2FsbCA6IGJzUmVzdWx0LnB1dCkgLSBtYXJrZXRQcmljZTtcbiAgfVxuXG4gIHJldHVybiBiO1xufVxuXG4vKipcbiAqIEZpbmQgYXQtdGhlLW1vbmV5IHN0cmlrZSBhbmQgY2FsY3VsYXRlIEFUTSBpbXBsaWVkIHZvbGF0aWxpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBVE1TdHJpa2Uoc3RyaWtlczogbnVtYmVyW10sIHNwb3Q6IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChzdHJpa2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gc3RyaWtlcyBwcm92aWRlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHN0cmlrZXMucmVkdWNlKChjbG9zZXN0LCBzdHJpa2UpID0+IFxuICAgIE1hdGguYWJzKHN0cmlrZSAtIHNwb3QpIDwgTWF0aC5hYnMoY2xvc2VzdCAtIHNwb3QpID8gc3RyaWtlIDogY2xvc2VzdFxuICApO1xufVxuIl0sIm5hbWVzIjpbIm5vcm1DREYiLCJ4IiwiYTEiLCJhMiIsImEzIiwiYTQiLCJhNSIsInAiLCJzaWduIiwiTWF0aCIsImFicyIsInNxcnQiLCJ0IiwieSIsImV4cCIsIm5vcm1QREYiLCJQSSIsImNhbGN1bGF0ZUQxRDIiLCJwYXJhbXMiLCJTIiwiSyIsIlQiLCJyIiwicSIsIml2IiwiRXJyb3IiLCJkMSIsImxvZyIsImQyIiwiYmxhY2tTY2hvbGVzIiwiTmQxIiwiTmQyIiwiTmVnRDEiLCJOZWdEMiIsIm5kMSIsImRpc2NvdW50RmFjdG9yIiwiZGl2aWRlbmRGYWN0b3IiLCJjYWxsIiwicHV0IiwiZGVsdGEiLCJnYW1tYSIsInRoZXRhIiwidmVnYSIsInJobyIsIm1heCIsImltcGxpZWRWb2xCcmVudCIsIm1hcmtldFByaWNlIiwiaXNDYWxsIiwidG9sZXJhbmNlIiwibWF4SXRlcmF0aW9ucyIsImludHJpbnNpYyIsInZvbExvdyIsInZvbEhpZ2giLCJ0ZXN0TG93IiwidGVzdEhpZ2giLCJwcmljZUxvdyIsInByaWNlSGlnaCIsImEiLCJiIiwiYyIsImZhIiwiZmIiLCJmYyIsIml0ZXIiLCJ0b2wiLCJtIiwicyIsIm1pbiIsImJzUmVzdWx0IiwiZmluZEFUTVN0cmlrZSIsInN0cmlrZXMiLCJzcG90IiwibGVuZ3RoIiwicmVkdWNlIiwiY2xvc2VzdCIsInN0cmlrZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/pricing/blackScholes.ts\n");

/***/ }),

/***/ "(rsc)/./lib/schemas.ts":
/*!************************!*\
  !*** ./lib/schemas.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateSchema: () => (/* binding */ DateSchema),\n/* harmony export */   EarningsDataSchema: () => (/* binding */ EarningsDataSchema),\n/* harmony export */   EarningsEventSchema: () => (/* binding */ EarningsEventSchema),\n/* harmony export */   EarningsRequestSchema: () => (/* binding */ EarningsRequestSchema),\n/* harmony export */   EarningsResponseSchema: () => (/* binding */ EarningsResponseSchema),\n/* harmony export */   ErrorResponseSchema: () => (/* binding */ ErrorResponseSchema),\n/* harmony export */   ExpectedMoveRequestSchema: () => (/* binding */ ExpectedMoveRequestSchema),\n/* harmony export */   ExpectedMoveResponseSchema: () => (/* binding */ ExpectedMoveResponseSchema),\n/* harmony export */   ExpectedMoveSchema: () => (/* binding */ ExpectedMoveSchema),\n/* harmony export */   ExpirySchema: () => (/* binding */ ExpirySchema),\n/* harmony export */   HealthResponseSchema: () => (/* binding */ HealthResponseSchema),\n/* harmony export */   HitResponseSchema: () => (/* binding */ HitResponseSchema),\n/* harmony export */   IVStatsSchema: () => (/* binding */ IVStatsSchema),\n/* harmony export */   OptionSchema: () => (/* binding */ OptionSchema),\n/* harmony export */   OptionalExpirySchema: () => (/* binding */ OptionalExpirySchema),\n/* harmony export */   OptionsChainSchema: () => (/* binding */ OptionsChainSchema),\n/* harmony export */   OptionsRequestSchema: () => (/* binding */ OptionsRequestSchema),\n/* harmony export */   OptionsResponseSchema: () => (/* binding */ OptionsResponseSchema),\n/* harmony export */   RealizedMoveSchema: () => (/* binding */ RealizedMoveSchema),\n/* harmony export */   SymbolSchema: () => (/* binding */ SymbolSchema),\n/* harmony export */   TopMoversRequestSchema: () => (/* binding */ TopMoversRequestSchema),\n/* harmony export */   TopMoversResponseSchema: () => (/* binding */ TopMoversResponseSchema),\n/* harmony export */   createApiResponse: () => (/* binding */ createApiResponse),\n/* harmony export */   validateRequest: () => (/* binding */ validateRequest)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/ZodError.js\");\n/**\n * Zod schemas for API validation and type safety\n * Used across all API routes for request/response validation\n */ \n/**\n * Common validation schemas\n */ const SymbolSchema = zod__WEBPACK_IMPORTED_MODULE_0__.string().min(1, \"Symbol is required\").max(10, \"Symbol too long\").regex(/^[A-Za-z0-9.-]+$/, \"Invalid symbol format\").transform((s)=>s.toUpperCase());\nconst ExpirySchema = zod__WEBPACK_IMPORTED_MODULE_0__.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, \"Expiry must be in YYYY-MM-DD format\").refine((date)=>{\n    const parsed = new Date(date);\n    const now = new Date();\n    return parsed > now;\n}, \"Expiry must be in the future\");\nconst OptionalExpirySchema = zod__WEBPACK_IMPORTED_MODULE_0__.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, \"Expiry must be in YYYY-MM-DD format\").refine((date)=>{\n    const parsed = new Date(date);\n    const now = new Date();\n    return parsed > now;\n}, \"Expiry must be in the future\").optional();\nconst DateSchema = zod__WEBPACK_IMPORTED_MODULE_0__.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/, \"Date must be in YYYY-MM-DD format\");\n/**\n * Options chain schemas\n */ const OptionSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    strike: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Strike must be positive\"),\n    mid: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Mid price cannot be negative\"),\n    bid: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Bid price cannot be negative\"),\n    ask: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Ask price cannot be negative\"),\n    iv: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"IV must be positive\").optional(),\n    delta: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    gamma: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    theta: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    vega: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    rho: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    volume: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative().optional(),\n    openInterest: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative().optional(),\n    lastPrice: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative().optional(),\n    change: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    changePct: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional()\n});\nconst OptionsChainSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    symbol: SymbolSchema,\n    spot: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Spot price must be positive\"),\n    expiryDate: ExpirySchema,\n    daysToExpiry: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Days to expiry must be positive\"),\n    strikes: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.number().positive()).min(1, \"At least one strike required\"),\n    calls: zod__WEBPACK_IMPORTED_MODULE_0__.array(OptionSchema).min(1, \"At least one call required\"),\n    puts: zod__WEBPACK_IMPORTED_MODULE_0__.array(OptionSchema).min(1, \"At least one put required\"),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime().optional(),\n    source: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\n/**\n * Expected move schemas\n */ const ExpectedMoveSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    straddle: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        abs: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Straddle move cannot be negative\"),\n        pct: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Straddle percentage cannot be negative\")\n    }),\n    iv: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        abs: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"IV move cannot be negative\"),\n        pct: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"IV percentage cannot be negative\")\n    }),\n    bands: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        oneSigma: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            upper: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n            lower: zod__WEBPACK_IMPORTED_MODULE_0__.number()\n        }),\n        twoSigma: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            upper: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n            lower: zod__WEBPACK_IMPORTED_MODULE_0__.number()\n        })\n    }),\n    confidence: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        straddle: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n            \"high\",\n            \"medium\",\n            \"low\"\n        ]),\n        iv: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n            \"high\",\n            \"medium\",\n            \"low\"\n        ])\n    })\n});\n/**\n * IV statistics schemas\n */ const IVStatsSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    rank: zod__WEBPACK_IMPORTED_MODULE_0__.number().min(0).max(1, \"IV rank must be between 0 and 1\"),\n    percentile: zod__WEBPACK_IMPORTED_MODULE_0__.number().min(0).max(100, \"Percentile must be between 0 and 100\"),\n    current: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Current IV must be positive\"),\n    min: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Min IV must be positive\"),\n    max: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Max IV must be positive\"),\n    mean: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Mean IV must be positive\"),\n    median: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Median IV must be positive\"),\n    stdDev: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(\"Standard deviation cannot be negative\"),\n    daysInSample: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(\"Days in sample must be positive\")\n});\n/**\n * Earnings schemas\n */ const EarningsEventSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    date: DateSchema,\n    confidence: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        \"confirmed\",\n        \"estimated\"\n    ]),\n    timing: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        \"bmo\",\n        \"amc\",\n        \"unknown\"\n    ]).optional(),\n    estimate: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        eps: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n        revenue: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional()\n    }).optional()\n});\nconst RealizedMoveSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    date: DateSchema,\n    realizedMovePct: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    priceChange: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n    priceBefore: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n    priceAfter: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n    volume: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative().optional()\n});\nconst EarningsDataSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    symbol: SymbolSchema,\n    next: EarningsEventSchema.optional(),\n    last: zod__WEBPACK_IMPORTED_MODULE_0__.array(RealizedMoveSchema).max(8, \"Maximum 8 historical earnings\"),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime().optional()\n});\n/**\n * API request schemas\n */ const OptionsRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    symbol: SymbolSchema,\n    expiry: OptionalExpirySchema\n});\nconst ExpectedMoveRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    symbol: SymbolSchema,\n    expiry: OptionalExpirySchema\n});\nconst EarningsRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    symbol: SymbolSchema\n});\nconst TopMoversRequestSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    date: DateSchema.optional(),\n    limit: zod__WEBPACK_IMPORTED_MODULE_0__.number().min(1).max(50).default(10)\n});\n/**\n * API response schemas\n */ const OptionsResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n    data: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        spot: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n        expiryUsed: ExpirySchema,\n        atm: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            strike: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n            callMid: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(),\n            putMid: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(),\n            iv: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n            T: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive()\n        }),\n        rows: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            strike: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive(),\n            call: OptionSchema,\n            put: OptionSchema\n        }))\n    }).optional(),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\nconst ExpectedMoveResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n    data: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        em: ExpectedMoveSchema,\n        ivRank: IVStatsSchema\n    }).optional(),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\nconst EarningsResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n    data: EarningsDataSchema.optional(),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\nconst HitResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n    data: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        count: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative()\n    }).optional(),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\nconst TopMoversResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n    data: zod__WEBPACK_IMPORTED_MODULE_0__.array(zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        symbol: SymbolSchema,\n        expectedMovePct: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative(),\n        spot: zod__WEBPACK_IMPORTED_MODULE_0__.number().positive().optional(),\n        volume: zod__WEBPACK_IMPORTED_MODULE_0__.number().nonnegative().optional()\n    })).optional(),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\n/**\n * Error response schema\n */ const ErrorResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    success: zod__WEBPACK_IMPORTED_MODULE_0__.literal(false),\n    error: zod__WEBPACK_IMPORTED_MODULE_0__.string(),\n    detail: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    hint: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime()\n});\n/**\n * Health check schema\n */ const HealthResponseSchema = zod__WEBPACK_IMPORTED_MODULE_0__.object({\n    status: zod__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\n        \"healthy\",\n        \"degraded\",\n        \"unhealthy\"\n    ]),\n    timestamp: zod__WEBPACK_IMPORTED_MODULE_0__.string().datetime(),\n    services: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n        redis: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            connected: zod__WEBPACK_IMPORTED_MODULE_0__.boolean(),\n            latency: zod__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n            error: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n        }),\n        cache: zod__WEBPACK_IMPORTED_MODULE_0__.object({\n            l1Stats: zod__WEBPACK_IMPORTED_MODULE_0__.record(zod__WEBPACK_IMPORTED_MODULE_0__.object({\n                size: zod__WEBPACK_IMPORTED_MODULE_0__.number(),\n                hitRate: zod__WEBPACK_IMPORTED_MODULE_0__.number()\n            }))\n        })\n    }),\n    version: zod__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n});\n/**\n * Utility functions for schema validation\n */ function validateRequest(schema, data) {\n    try {\n        const result = schema.parse(data);\n        return {\n            success: true,\n            data: result\n        };\n    } catch (error) {\n        if (error instanceof zod__WEBPACK_IMPORTED_MODULE_1__.ZodError) {\n            return {\n                success: false,\n                error: \"Validation failed\",\n                details: error.errors.map((e)=>`${e.path.join(\".\")}: ${e.message}`)\n            };\n        }\n        return {\n            success: false,\n            error: \"Unknown validation error\",\n            details: [\n                error instanceof Error ? error.message : \"Unknown error\"\n            ]\n        };\n    }\n}\n/**\n * Create standardized API response\n */ function createApiResponse(data, error, detail, hint) {\n    return {\n        success: !error,\n        ...data && {\n            data\n        },\n        ...error && {\n            error\n        },\n        ...detail && {\n            detail\n        },\n        ...hint && {\n            hint\n        },\n        timestamp: new Date().toISOString()\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVM7WUFBRUE7UUFBTSxDQUFDO1FBQ3RCLEdBQUlXLFVBQVU7WUFBRUE7UUFBTyxDQUFDO1FBQ3hCLEdBQUlDLFFBQVE7WUFBRUE7UUFBSyxDQUFDO1FBQ3BCbEUsV0FBVyxJQUFJbEMsT0FBTytILFdBQVc7SUFDbkM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YW50aXYvLi9saWIvc2NoZW1hcy50cz80NWMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogWm9kIHNjaGVtYXMgZm9yIEFQSSB2YWxpZGF0aW9uIGFuZCB0eXBlIHNhZmV0eVxuICogVXNlZCBhY3Jvc3MgYWxsIEFQSSByb3V0ZXMgZm9yIHJlcXVlc3QvcmVzcG9uc2UgdmFsaWRhdGlvblxuICovXG5cbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuXG4vKipcbiAqIENvbW1vbiB2YWxpZGF0aW9uIHNjaGVtYXNcbiAqL1xuZXhwb3J0IGNvbnN0IFN5bWJvbFNjaGVtYSA9IHouc3RyaW5nKClcbiAgLm1pbigxLCAnU3ltYm9sIGlzIHJlcXVpcmVkJylcbiAgLm1heCgxMCwgJ1N5bWJvbCB0b28gbG9uZycpXG4gIC5yZWdleCgvXltBLVphLXowLTkuLV0rJC8sICdJbnZhbGlkIHN5bWJvbCBmb3JtYXQnKVxuICAudHJhbnNmb3JtKHMgPT4gcy50b1VwcGVyQ2FzZSgpKTtcblxuZXhwb3J0IGNvbnN0IEV4cGlyeVNjaGVtYSA9IHouc3RyaW5nKClcbiAgLnJlZ2V4KC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLywgJ0V4cGlyeSBtdXN0IGJlIGluIFlZWVktTU0tREQgZm9ybWF0JylcbiAgLnJlZmluZShkYXRlID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiBwYXJzZWQgPiBub3c7XG4gIH0sICdFeHBpcnkgbXVzdCBiZSBpbiB0aGUgZnV0dXJlJyk7XG5cbmV4cG9ydCBjb25zdCBPcHRpb25hbEV4cGlyeVNjaGVtYSA9IHouc3RyaW5nKClcbiAgLnJlZ2V4KC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0kLywgJ0V4cGlyeSBtdXN0IGJlIGluIFlZWVktTU0tREQgZm9ybWF0JylcbiAgLnJlZmluZShkYXRlID0+IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiBwYXJzZWQgPiBub3c7XG4gIH0sICdFeHBpcnkgbXVzdCBiZSBpbiB0aGUgZnV0dXJlJylcbiAgLm9wdGlvbmFsKCk7XG5cbmV4cG9ydCBjb25zdCBEYXRlU2NoZW1hID0gei5zdHJpbmcoKVxuICAucmVnZXgoL15cXGR7NH0tXFxkezJ9LVxcZHsyfSQvLCAnRGF0ZSBtdXN0IGJlIGluIFlZWVktTU0tREQgZm9ybWF0Jyk7XG5cbi8qKlxuICogT3B0aW9ucyBjaGFpbiBzY2hlbWFzXG4gKi9cbmV4cG9ydCBjb25zdCBPcHRpb25TY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN0cmlrZTogei5udW1iZXIoKS5wb3NpdGl2ZSgnU3RyaWtlIG11c3QgYmUgcG9zaXRpdmUnKSxcbiAgbWlkOiB6Lm51bWJlcigpLm5vbm5lZ2F0aXZlKCdNaWQgcHJpY2UgY2Fubm90IGJlIG5lZ2F0aXZlJyksXG4gIGJpZDogei5udW1iZXIoKS5ub25uZWdhdGl2ZSgnQmlkIHByaWNlIGNhbm5vdCBiZSBuZWdhdGl2ZScpLFxuICBhc2s6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoJ0FzayBwcmljZSBjYW5ub3QgYmUgbmVnYXRpdmUnKSxcbiAgaXY6IHoubnVtYmVyKCkucG9zaXRpdmUoJ0lWIG11c3QgYmUgcG9zaXRpdmUnKS5vcHRpb25hbCgpLFxuICBkZWx0YTogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICBnYW1tYTogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB0aGV0YTogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB2ZWdhOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gIHJobzogei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB2b2x1bWU6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKS5vcHRpb25hbCgpLFxuICBvcGVuSW50ZXJlc3Q6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKS5vcHRpb25hbCgpLFxuICBsYXN0UHJpY2U6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKS5vcHRpb25hbCgpLFxuICBjaGFuZ2U6IHoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgY2hhbmdlUGN0OiB6Lm51bWJlcigpLm9wdGlvbmFsKClcbn0pO1xuXG5leHBvcnQgY29uc3QgT3B0aW9uc0NoYWluU2NoZW1hID0gei5vYmplY3Qoe1xuICBzeW1ib2w6IFN5bWJvbFNjaGVtYSxcbiAgc3BvdDogei5udW1iZXIoKS5wb3NpdGl2ZSgnU3BvdCBwcmljZSBtdXN0IGJlIHBvc2l0aXZlJyksXG4gIGV4cGlyeURhdGU6IEV4cGlyeVNjaGVtYSxcbiAgZGF5c1RvRXhwaXJ5OiB6Lm51bWJlcigpLnBvc2l0aXZlKCdEYXlzIHRvIGV4cGlyeSBtdXN0IGJlIHBvc2l0aXZlJyksXG4gIHN0cmlrZXM6IHouYXJyYXkoei5udW1iZXIoKS5wb3NpdGl2ZSgpKS5taW4oMSwgJ0F0IGxlYXN0IG9uZSBzdHJpa2UgcmVxdWlyZWQnKSxcbiAgY2FsbHM6IHouYXJyYXkoT3B0aW9uU2NoZW1hKS5taW4oMSwgJ0F0IGxlYXN0IG9uZSBjYWxsIHJlcXVpcmVkJyksXG4gIHB1dHM6IHouYXJyYXkoT3B0aW9uU2NoZW1hKS5taW4oMSwgJ0F0IGxlYXN0IG9uZSBwdXQgcmVxdWlyZWQnKSxcbiAgdGltZXN0YW1wOiB6LnN0cmluZygpLmRhdGV0aW1lKCkub3B0aW9uYWwoKSxcbiAgc291cmNlOiB6LnN0cmluZygpLm9wdGlvbmFsKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIG1vdmUgc2NoZW1hc1xuICovXG5leHBvcnQgY29uc3QgRXhwZWN0ZWRNb3ZlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdHJhZGRsZTogei5vYmplY3Qoe1xuICAgIGFiczogei5udW1iZXIoKS5ub25uZWdhdGl2ZSgnU3RyYWRkbGUgbW92ZSBjYW5ub3QgYmUgbmVnYXRpdmUnKSxcbiAgICBwY3Q6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoJ1N0cmFkZGxlIHBlcmNlbnRhZ2UgY2Fubm90IGJlIG5lZ2F0aXZlJylcbiAgfSksXG4gIGl2OiB6Lm9iamVjdCh7XG4gICAgYWJzOiB6Lm51bWJlcigpLm5vbm5lZ2F0aXZlKCdJViBtb3ZlIGNhbm5vdCBiZSBuZWdhdGl2ZScpLFxuICAgIHBjdDogei5udW1iZXIoKS5ub25uZWdhdGl2ZSgnSVYgcGVyY2VudGFnZSBjYW5ub3QgYmUgbmVnYXRpdmUnKVxuICB9KSxcbiAgYmFuZHM6IHoub2JqZWN0KHtcbiAgICBvbmVTaWdtYTogei5vYmplY3Qoe1xuICAgICAgdXBwZXI6IHoubnVtYmVyKCksXG4gICAgICBsb3dlcjogei5udW1iZXIoKVxuICAgIH0pLFxuICAgIHR3b1NpZ21hOiB6Lm9iamVjdCh7XG4gICAgICB1cHBlcjogei5udW1iZXIoKSxcbiAgICAgIGxvd2VyOiB6Lm51bWJlcigpXG4gICAgfSlcbiAgfSksXG4gIGNvbmZpZGVuY2U6IHoub2JqZWN0KHtcbiAgICBzdHJhZGRsZTogei5lbnVtKFsnaGlnaCcsICdtZWRpdW0nLCAnbG93J10pLFxuICAgIGl2OiB6LmVudW0oWydoaWdoJywgJ21lZGl1bScsICdsb3cnXSlcbiAgfSlcbn0pO1xuXG4vKipcbiAqIElWIHN0YXRpc3RpY3Mgc2NoZW1hc1xuICovXG5leHBvcnQgY29uc3QgSVZTdGF0c1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgcmFuazogei5udW1iZXIoKS5taW4oMCkubWF4KDEsICdJViByYW5rIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxJyksXG4gIHBlcmNlbnRpbGU6IHoubnVtYmVyKCkubWluKDApLm1heCgxMDAsICdQZXJjZW50aWxlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAnKSxcbiAgY3VycmVudDogei5udW1iZXIoKS5wb3NpdGl2ZSgnQ3VycmVudCBJViBtdXN0IGJlIHBvc2l0aXZlJyksXG4gIG1pbjogei5udW1iZXIoKS5wb3NpdGl2ZSgnTWluIElWIG11c3QgYmUgcG9zaXRpdmUnKSxcbiAgbWF4OiB6Lm51bWJlcigpLnBvc2l0aXZlKCdNYXggSVYgbXVzdCBiZSBwb3NpdGl2ZScpLFxuICBtZWFuOiB6Lm51bWJlcigpLnBvc2l0aXZlKCdNZWFuIElWIG11c3QgYmUgcG9zaXRpdmUnKSxcbiAgbWVkaWFuOiB6Lm51bWJlcigpLnBvc2l0aXZlKCdNZWRpYW4gSVYgbXVzdCBiZSBwb3NpdGl2ZScpLFxuICBzdGREZXY6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoJ1N0YW5kYXJkIGRldmlhdGlvbiBjYW5ub3QgYmUgbmVnYXRpdmUnKSxcbiAgZGF5c0luU2FtcGxlOiB6Lm51bWJlcigpLnBvc2l0aXZlKCdEYXlzIGluIHNhbXBsZSBtdXN0IGJlIHBvc2l0aXZlJylcbn0pO1xuXG4vKipcbiAqIEVhcm5pbmdzIHNjaGVtYXNcbiAqL1xuZXhwb3J0IGNvbnN0IEVhcm5pbmdzRXZlbnRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRhdGU6IERhdGVTY2hlbWEsXG4gIGNvbmZpZGVuY2U6IHouZW51bShbJ2NvbmZpcm1lZCcsICdlc3RpbWF0ZWQnXSksXG4gIHRpbWluZzogei5lbnVtKFsnYm1vJywgJ2FtYycsICd1bmtub3duJ10pLm9wdGlvbmFsKCksIC8vIEJlZm9yZSBtYXJrZXQgb3BlbiwgYWZ0ZXIgbWFya2V0IGNsb3NlXG4gIGVzdGltYXRlOiB6Lm9iamVjdCh7XG4gICAgZXBzOiB6Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgcmV2ZW51ZTogei5udW1iZXIoKS5vcHRpb25hbCgpXG4gIH0pLm9wdGlvbmFsKClcbn0pO1xuXG5leHBvcnQgY29uc3QgUmVhbGl6ZWRNb3ZlU2NoZW1hID0gei5vYmplY3Qoe1xuICBkYXRlOiBEYXRlU2NoZW1hLFxuICByZWFsaXplZE1vdmVQY3Q6IHoubnVtYmVyKCksXG4gIHByaWNlQ2hhbmdlOiB6Lm51bWJlcigpLFxuICBwcmljZUJlZm9yZTogei5udW1iZXIoKS5wb3NpdGl2ZSgpLFxuICBwcmljZUFmdGVyOiB6Lm51bWJlcigpLnBvc2l0aXZlKCksXG4gIHZvbHVtZTogei5udW1iZXIoKS5ub25uZWdhdGl2ZSgpLm9wdGlvbmFsKClcbn0pO1xuXG5leHBvcnQgY29uc3QgRWFybmluZ3NEYXRhU2NoZW1hID0gei5vYmplY3Qoe1xuICBzeW1ib2w6IFN5bWJvbFNjaGVtYSxcbiAgbmV4dDogRWFybmluZ3NFdmVudFNjaGVtYS5vcHRpb25hbCgpLFxuICBsYXN0OiB6LmFycmF5KFJlYWxpemVkTW92ZVNjaGVtYSkubWF4KDgsICdNYXhpbXVtIDggaGlzdG9yaWNhbCBlYXJuaW5ncycpLFxuICB0aW1lc3RhbXA6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKS5vcHRpb25hbCgpXG59KTtcblxuLyoqXG4gKiBBUEkgcmVxdWVzdCBzY2hlbWFzXG4gKi9cbmV4cG9ydCBjb25zdCBPcHRpb25zUmVxdWVzdFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3ltYm9sOiBTeW1ib2xTY2hlbWEsXG4gIGV4cGlyeTogT3B0aW9uYWxFeHBpcnlTY2hlbWFcbn0pO1xuXG5leHBvcnQgY29uc3QgRXhwZWN0ZWRNb3ZlUmVxdWVzdFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3ltYm9sOiBTeW1ib2xTY2hlbWEsXG4gIGV4cGlyeTogT3B0aW9uYWxFeHBpcnlTY2hlbWFcbn0pO1xuXG5leHBvcnQgY29uc3QgRWFybmluZ3NSZXF1ZXN0U2NoZW1hID0gei5vYmplY3Qoe1xuICBzeW1ib2w6IFN5bWJvbFNjaGVtYVxufSk7XG5cbmV4cG9ydCBjb25zdCBUb3BNb3ZlcnNSZXF1ZXN0U2NoZW1hID0gei5vYmplY3Qoe1xuICBkYXRlOiBEYXRlU2NoZW1hLm9wdGlvbmFsKCksXG4gIGxpbWl0OiB6Lm51bWJlcigpLm1pbigxKS5tYXgoNTApLmRlZmF1bHQoMTApXG59KTtcblxuLyoqXG4gKiBBUEkgcmVzcG9uc2Ugc2NoZW1hc1xuICovXG5leHBvcnQgY29uc3QgT3B0aW9uc1Jlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdWNjZXNzOiB6LmJvb2xlYW4oKSxcbiAgZGF0YTogei5vYmplY3Qoe1xuICAgIHNwb3Q6IHoubnVtYmVyKCkucG9zaXRpdmUoKSxcbiAgICBleHBpcnlVc2VkOiBFeHBpcnlTY2hlbWEsXG4gICAgYXRtOiB6Lm9iamVjdCh7XG4gICAgICBzdHJpa2U6IHoubnVtYmVyKCkucG9zaXRpdmUoKSxcbiAgICAgIGNhbGxNaWQ6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKSxcbiAgICAgIHB1dE1pZDogei5udW1iZXIoKS5ub25uZWdhdGl2ZSgpLFxuICAgICAgaXY6IHoubnVtYmVyKCkucG9zaXRpdmUoKSxcbiAgICAgIFQ6IHoubnVtYmVyKCkucG9zaXRpdmUoKVxuICAgIH0pLFxuICAgIHJvd3M6IHouYXJyYXkoei5vYmplY3Qoe1xuICAgICAgc3RyaWtlOiB6Lm51bWJlcigpLnBvc2l0aXZlKCksXG4gICAgICBjYWxsOiBPcHRpb25TY2hlbWEsXG4gICAgICBwdXQ6IE9wdGlvblNjaGVtYVxuICAgIH0pKVxuICB9KS5vcHRpb25hbCgpLFxuICBlcnJvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0aW1lc3RhbXA6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKVxufSk7XG5cbmV4cG9ydCBjb25zdCBFeHBlY3RlZE1vdmVSZXNwb25zZVNjaGVtYSA9IHoub2JqZWN0KHtcbiAgc3VjY2Vzczogei5ib29sZWFuKCksXG4gIGRhdGE6IHoub2JqZWN0KHtcbiAgICBlbTogRXhwZWN0ZWRNb3ZlU2NoZW1hLFxuICAgIGl2UmFuazogSVZTdGF0c1NjaGVtYVxuICB9KS5vcHRpb25hbCgpLFxuICBlcnJvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0aW1lc3RhbXA6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKVxufSk7XG5cbmV4cG9ydCBjb25zdCBFYXJuaW5nc1Jlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdWNjZXNzOiB6LmJvb2xlYW4oKSxcbiAgZGF0YTogRWFybmluZ3NEYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gIGVycm9yOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHRpbWVzdGFtcDogei5zdHJpbmcoKS5kYXRldGltZSgpXG59KTtcblxuZXhwb3J0IGNvbnN0IEhpdFJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdWNjZXNzOiB6LmJvb2xlYW4oKSxcbiAgZGF0YTogei5vYmplY3Qoe1xuICAgIGNvdW50OiB6Lm51bWJlcigpLm5vbm5lZ2F0aXZlKClcbiAgfSkub3B0aW9uYWwoKSxcbiAgZXJyb3I6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdGltZXN0YW1wOiB6LnN0cmluZygpLmRhdGV0aW1lKClcbn0pO1xuXG5leHBvcnQgY29uc3QgVG9wTW92ZXJzUmVzcG9uc2VTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHN1Y2Nlc3M6IHouYm9vbGVhbigpLFxuICBkYXRhOiB6LmFycmF5KHoub2JqZWN0KHtcbiAgICBzeW1ib2w6IFN5bWJvbFNjaGVtYSxcbiAgICBleHBlY3RlZE1vdmVQY3Q6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKSxcbiAgICBzcG90OiB6Lm51bWJlcigpLnBvc2l0aXZlKCkub3B0aW9uYWwoKSxcbiAgICB2b2x1bWU6IHoubnVtYmVyKCkubm9ubmVnYXRpdmUoKS5vcHRpb25hbCgpXG4gIH0pKS5vcHRpb25hbCgpLFxuICBlcnJvcjogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICB0aW1lc3RhbXA6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKVxufSk7XG5cbi8qKlxuICogRXJyb3IgcmVzcG9uc2Ugc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCBFcnJvclJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdWNjZXNzOiB6LmxpdGVyYWwoZmFsc2UpLFxuICBlcnJvcjogei5zdHJpbmcoKSxcbiAgZGV0YWlsOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGhpbnQ6IHouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdGltZXN0YW1wOiB6LnN0cmluZygpLmRhdGV0aW1lKClcbn0pO1xuXG4vKipcbiAqIEhlYWx0aCBjaGVjayBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IEhlYWx0aFJlc3BvbnNlU2NoZW1hID0gei5vYmplY3Qoe1xuICBzdGF0dXM6IHouZW51bShbJ2hlYWx0aHknLCAnZGVncmFkZWQnLCAndW5oZWFsdGh5J10pLFxuICB0aW1lc3RhbXA6IHouc3RyaW5nKCkuZGF0ZXRpbWUoKSxcbiAgc2VydmljZXM6IHoub2JqZWN0KHtcbiAgICByZWRpczogei5vYmplY3Qoe1xuICAgICAgY29ubmVjdGVkOiB6LmJvb2xlYW4oKSxcbiAgICAgIGxhdGVuY3k6IHoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAgIGVycm9yOiB6LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICBjYWNoZTogei5vYmplY3Qoe1xuICAgICAgbDFTdGF0czogei5yZWNvcmQoei5vYmplY3Qoe1xuICAgICAgICBzaXplOiB6Lm51bWJlcigpLFxuICAgICAgICBoaXRSYXRlOiB6Lm51bWJlcigpXG4gICAgICB9KSlcbiAgICB9KVxuICB9KSxcbiAgdmVyc2lvbjogei5zdHJpbmcoKS5vcHRpb25hbCgpXG59KTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igc2NoZW1hIHZhbGlkYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmVxdWVzdDxUPihzY2hlbWE6IHouWm9kU2NoZW1hPFQ+LCBkYXRhOiB1bmtub3duKToge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogVDtcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIGRldGFpbHM/OiBzdHJpbmdbXTtcbn0ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5wYXJzZShkYXRhKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiB6LlpvZEVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdWYWxpZGF0aW9uIGZhaWxlZCcsXG4gICAgICAgIGRldGFpbHM6IGVycm9yLmVycm9ycy5tYXAoZSA9PiBgJHtlLnBhdGguam9pbignLicpfTogJHtlLm1lc3NhZ2V9YClcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnVW5rbm93biB2YWxpZGF0aW9uIGVycm9yJyxcbiAgICAgIGRldGFpbHM6IFtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ11cbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHN0YW5kYXJkaXplZCBBUEkgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFwaVJlc3BvbnNlPFQ+KFxuICBkYXRhPzogVCxcbiAgZXJyb3I/OiBzdHJpbmcsXG4gIGRldGFpbD86IHN0cmluZyxcbiAgaGludD86IHN0cmluZ1xuKToge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogVDtcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIGRldGFpbD86IHN0cmluZztcbiAgaGludD86IHN0cmluZztcbiAgdGltZXN0YW1wOiBzdHJpbmc7XG59IHtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiAhZXJyb3IsXG4gICAgLi4uKGRhdGEgJiYgeyBkYXRhIH0pLFxuICAgIC4uLihlcnJvciAmJiB7IGVycm9yIH0pLFxuICAgIC4uLihkZXRhaWwgJiYgeyBkZXRhaWwgfSksXG4gICAgLi4uKGhpbnQgJiYgeyBoaW50IH0pLFxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIH07XG59XG5cbi8qKlxuICogVHlwZSBleHBvcnRzIGZvciB1c2UgaW4gQVBJIHJvdXRlc1xuICovXG5leHBvcnQgdHlwZSBPcHRpb25zUmVxdWVzdCA9IHouaW5mZXI8dHlwZW9mIE9wdGlvbnNSZXF1ZXN0U2NoZW1hPjtcbmV4cG9ydCB0eXBlIEV4cGVjdGVkTW92ZVJlcXVlc3QgPSB6LmluZmVyPHR5cGVvZiBFeHBlY3RlZE1vdmVSZXF1ZXN0U2NoZW1hPjtcbmV4cG9ydCB0eXBlIEVhcm5pbmdzUmVxdWVzdCA9IHouaW5mZXI8dHlwZW9mIEVhcm5pbmdzUmVxdWVzdFNjaGVtYT47XG5leHBvcnQgdHlwZSBUb3BNb3ZlcnNSZXF1ZXN0ID0gei5pbmZlcjx0eXBlb2YgVG9wTW92ZXJzUmVxdWVzdFNjaGVtYT47XG5cbmV4cG9ydCB0eXBlIE9wdGlvbnNSZXNwb25zZSA9IHouaW5mZXI8dHlwZW9mIE9wdGlvbnNSZXNwb25zZVNjaGVtYT47XG5leHBvcnQgdHlwZSBFeHBlY3RlZE1vdmVSZXNwb25zZSA9IHouaW5mZXI8dHlwZW9mIEV4cGVjdGVkTW92ZVJlc3BvbnNlU2NoZW1hPjtcbmV4cG9ydCB0eXBlIEVhcm5pbmdzUmVzcG9uc2UgPSB6LmluZmVyPHR5cGVvZiBFYXJuaW5nc1Jlc3BvbnNlU2NoZW1hPjtcbmV4cG9ydCB0eXBlIEhpdFJlc3BvbnNlID0gei5pbmZlcjx0eXBlb2YgSGl0UmVzcG9uc2VTY2hlbWE+O1xuZXhwb3J0IHR5cGUgVG9wTW92ZXJzUmVzcG9uc2UgPSB6LmluZmVyPHR5cGVvZiBUb3BNb3ZlcnNSZXNwb25zZVNjaGVtYT47XG5leHBvcnQgdHlwZSBFcnJvclJlc3BvbnNlID0gei5pbmZlcjx0eXBlb2YgRXJyb3JSZXNwb25zZVNjaGVtYT47XG5leHBvcnQgdHlwZSBIZWFsdGhSZXNwb25zZSA9IHouaW5mZXI8dHlwZW9mIEhlYWx0aFJlc3BvbnNlU2NoZW1hPjtcbiJdLCJuYW1lcyI6WyJ6IiwiU3ltYm9sU2NoZW1hIiwic3RyaW5nIiwibWluIiwibWF4IiwicmVnZXgiLCJ0cmFuc2Zvcm0iLCJzIiwidG9VcHBlckNhc2UiLCJFeHBpcnlTY2hlbWEiLCJyZWZpbmUiLCJkYXRlIiwicGFyc2VkIiwiRGF0ZSIsIm5vdyIsIk9wdGlvbmFsRXhwaXJ5U2NoZW1hIiwib3B0aW9uYWwiLCJEYXRlU2NoZW1hIiwiT3B0aW9uU2NoZW1hIiwib2JqZWN0Iiwic3RyaWtlIiwibnVtYmVyIiwicG9zaXRpdmUiLCJtaWQiLCJub25uZWdhdGl2ZSIsImJpZCIsImFzayIsIml2IiwiZGVsdGEiLCJnYW1tYSIsInRoZXRhIiwidmVnYSIsInJobyIsInZvbHVtZSIsIm9wZW5JbnRlcmVzdCIsImxhc3RQcmljZSIsImNoYW5nZSIsImNoYW5nZVBjdCIsIk9wdGlvbnNDaGFpblNjaGVtYSIsInN5bWJvbCIsInNwb3QiLCJleHBpcnlEYXRlIiwiZGF5c1RvRXhwaXJ5Iiwic3RyaWtlcyIsImFycmF5IiwiY2FsbHMiLCJwdXRzIiwidGltZXN0YW1wIiwiZGF0ZXRpbWUiLCJzb3VyY2UiLCJFeHBlY3RlZE1vdmVTY2hlbWEiLCJzdHJhZGRsZSIsImFicyIsInBjdCIsImJhbmRzIiwib25lU2lnbWEiLCJ1cHBlciIsImxvd2VyIiwidHdvU2lnbWEiLCJjb25maWRlbmNlIiwiZW51bSIsIklWU3RhdHNTY2hlbWEiLCJyYW5rIiwicGVyY2VudGlsZSIsImN1cnJlbnQiLCJtZWFuIiwibWVkaWFuIiwic3RkRGV2IiwiZGF5c0luU2FtcGxlIiwiRWFybmluZ3NFdmVudFNjaGVtYSIsInRpbWluZyIsImVzdGltYXRlIiwiZXBzIiwicmV2ZW51ZSIsIlJlYWxpemVkTW92ZVNjaGVtYSIsInJlYWxpemVkTW92ZVBjdCIsInByaWNlQ2hhbmdlIiwicHJpY2VCZWZvcmUiLCJwcmljZUFmdGVyIiwiRWFybmluZ3NEYXRhU2NoZW1hIiwibmV4dCIsImxhc3QiLCJPcHRpb25zUmVxdWVzdFNjaGVtYSIsImV4cGlyeSIsIkV4cGVjdGVkTW92ZVJlcXVlc3RTY2hlbWEiLCJFYXJuaW5nc1JlcXVlc3RTY2hlbWEiLCJUb3BNb3ZlcnNSZXF1ZXN0U2NoZW1hIiwibGltaXQiLCJkZWZhdWx0IiwiT3B0aW9uc1Jlc3BvbnNlU2NoZW1hIiwic3VjY2VzcyIsImJvb2xlYW4iLCJkYXRhIiwiZXhwaXJ5VXNlZCIsImF0bSIsImNhbGxNaWQiLCJwdXRNaWQiLCJUIiwicm93cyIsImNhbGwiLCJwdXQiLCJlcnJvciIsIkV4cGVjdGVkTW92ZVJlc3BvbnNlU2NoZW1hIiwiZW0iLCJpdlJhbmsiLCJFYXJuaW5nc1Jlc3BvbnNlU2NoZW1hIiwiSGl0UmVzcG9uc2VTY2hlbWEiLCJjb3VudCIsIlRvcE1vdmVyc1Jlc3BvbnNlU2NoZW1hIiwiZXhwZWN0ZWRNb3ZlUGN0IiwiRXJyb3JSZXNwb25zZVNjaGVtYSIsImxpdGVyYWwiLCJkZXRhaWwiLCJoaW50IiwiSGVhbHRoUmVzcG9uc2VTY2hlbWEiLCJzdGF0dXMiLCJzZXJ2aWNlcyIsInJlZGlzIiwiY29ubmVjdGVkIiwibGF0ZW5jeSIsImNhY2hlIiwibDFTdGF0cyIsInJlY29yZCIsInNpemUiLCJoaXRSYXRlIiwidmVyc2lvbiIsInZhbGlkYXRlUmVxdWVzdCIsInNjaGVtYSIsInJlc3VsdCIsInBhcnNlIiwiWm9kRXJyb3IiLCJkZXRhaWxzIiwiZXJyb3JzIiwibWFwIiwiZSIsInBhdGgiLCJqb2luIiwibWVzc2FnZSIsIkVycm9yIiwiY3JlYXRlQXBpUmVzcG9uc2UiLCJ0b0lTT1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/schemas.ts\n");

/***/ }),

/***/ "(rsc)/./lib/services/expectedMove.ts":
/*!**************************************!*\
  !*** ./lib/services/expectedMove.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assessConfidence: () => (/* binding */ assessConfidence),\n/* harmony export */   calculateIVMove: () => (/* binding */ calculateIVMove),\n/* harmony export */   calculatePriceBands: () => (/* binding */ calculatePriceBands),\n/* harmony export */   calculateStraddleMove: () => (/* binding */ calculateStraddleMove),\n/* harmony export */   computeExpectedMove: () => (/* binding */ computeExpectedMove),\n/* harmony export */   findATMData: () => (/* binding */ findATMData),\n/* harmony export */   formatExpectedMove: () => (/* binding */ formatExpectedMove)\n/* harmony export */ });\n/* harmony import */ var _pricing_blackScholes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pricing/blackScholes */ \"(rsc)/./lib/pricing/blackScholes.ts\");\n/**\n * Expected Move Service\n * Calculates expected moves using both straddle and IV methods\n * Provides price bands for 1σ and 2σ moves\n */ \n/**\n * Find ATM options data from chain\n */ function findATMData(chain) {\n    const atmStrike = (0,_pricing_blackScholes__WEBPACK_IMPORTED_MODULE_0__.findATMStrike)(chain.strikes, chain.spot);\n    // Find corresponding call and put\n    const atmCall = chain.calls.find((c)=>c.strike === atmStrike);\n    const atmPut = chain.puts.find((p)=>p.strike === atmStrike);\n    if (!atmCall || !atmPut) {\n        throw new Error(`ATM options not found for strike ${atmStrike}`);\n    }\n    // Calculate implied volatility - prefer average if both available\n    let iv;\n    const callIV = atmCall.iv;\n    const putIV = atmPut.iv;\n    if (callIV && putIV) {\n        iv = (callIV + putIV) / 2;\n    } else if (callIV) {\n        iv = callIV;\n    } else if (putIV) {\n        iv = putIV;\n    } else {\n        // Fallback: estimate IV from option prices\n        iv = estimateIVFromPrices(chain.spot, atmStrike, atmCall.mid, chain.daysToExpiry);\n    }\n    return {\n        strike: atmStrike,\n        callMid: atmCall.mid,\n        putMid: atmPut.mid,\n        iv: iv,\n        T: chain.daysToExpiry / 365\n    };\n}\n/**\n * Estimate IV from option prices when not available\n */ function estimateIVFromPrices(spot, strike, optionPrice, daysToExpiry) {\n    const T = daysToExpiry / 365;\n    const moneyness = spot / strike;\n    // Simple heuristic based on time value and moneyness\n    // This is a rough approximation - real IV should come from data provider\n    let baseIV = 0.20; // 20% base volatility\n    // Adjust for time to expiry\n    if (T < 0.1) baseIV *= 1.5; // Short-term options tend to have higher IV\n    if (T > 0.5) baseIV *= 0.8; // Longer-term options tend to have lower IV\n    // Adjust for moneyness\n    const timeValue = optionPrice - Math.max(0, spot - strike);\n    if (timeValue > 0) {\n        baseIV *= Math.min(2.0, timeValue / (spot * 0.02)); // Scale by time value\n    }\n    return Math.max(0.05, Math.min(2.0, baseIV)); // Clamp between 5% and 200%\n}\n/**\n * Calculate expected move using straddle method\n */ function calculateStraddleMove(atm, spot) {\n    const straddlePrice = atm.callMid + atm.putMid;\n    return {\n        abs: straddlePrice,\n        pct: straddlePrice / spot * 100\n    };\n}\n/**\n * Calculate expected move using IV method\n */ function calculateIVMove(atm, spot) {\n    const ivMove = spot * atm.iv * Math.sqrt(atm.T);\n    return {\n        abs: ivMove,\n        pct: ivMove / spot * 100\n    };\n}\n/**\n * Calculate price bands for 1σ and 2σ moves\n */ function calculatePriceBands(spot, ivMove) {\n    return {\n        oneSigma: {\n            upper: spot + ivMove,\n            lower: spot - ivMove\n        },\n        twoSigma: {\n            upper: spot + 2 * ivMove,\n            lower: spot - 2 * ivMove\n        }\n    };\n}\n/**\n * Assess confidence in expected move calculations\n */ function assessConfidence(chain, atm) {\n    // Factors that affect confidence:\n    // 1. Volume and open interest\n    // 2. Bid-ask spreads\n    // 3. Time to expiry\n    // 4. IV availability and consistency\n    const atmCall = chain.calls.find((c)=>c.strike === atm.strike);\n    const atmPut = chain.puts.find((p)=>p.strike === atm.strike);\n    let straddleConfidence = \"medium\";\n    let ivConfidence = \"medium\";\n    if (atmCall && atmPut) {\n        // Check bid-ask spreads\n        const callSpread = (atmCall.ask - atmCall.bid) / atmCall.mid;\n        const putSpread = (atmPut.ask - atmPut.bid) / atmPut.mid;\n        const avgSpread = (callSpread + putSpread) / 2;\n        if (avgSpread < 0.10) {\n            straddleConfidence = \"high\";\n        } else if (avgSpread > 0.25) {\n            straddleConfidence = \"low\";\n        }\n        // Check volume (if available) - adjust confidence but don't override good spreads\n        const totalVolume = (atmCall.volume || 0) + (atmPut.volume || 0);\n        if (totalVolume > 100) {\n            // High volume reinforces confidence\n            if (straddleConfidence === \"medium\") straddleConfidence = \"high\";\n        } else if (totalVolume < 10) {\n            // Low volume reduces confidence\n            if (straddleConfidence === \"high\") straddleConfidence = \"medium\";\n            if (straddleConfidence === \"medium\") straddleConfidence = \"low\";\n        }\n    }\n    // IV confidence based on availability and time to expiry\n    if (atmCall?.iv && atmPut?.iv) {\n        const ivDiff = Math.abs(atmCall.iv - atmPut.iv);\n        if (ivDiff < 0.02) {\n            ivConfidence = \"high\";\n        } else if (ivDiff > 0.05) {\n            ivConfidence = \"low\";\n        }\n    } else if (!atmCall?.iv && !atmPut?.iv) {\n        ivConfidence = \"low\"; // No IV data available\n    }\n    // Adjust for time to expiry\n    if (atm.T < 0.02) {\n        straddleConfidence = straddleConfidence === \"high\" ? \"medium\" : \"low\";\n        ivConfidence = ivConfidence === \"high\" ? \"medium\" : \"low\";\n    }\n    return {\n        straddle: straddleConfidence,\n        iv: ivConfidence\n    };\n}\n/**\n * Main function to compute expected move\n */ function computeExpectedMove(chain) {\n    const atm = findATMData(chain);\n    const straddleMove = calculateStraddleMove(atm, chain.spot);\n    const ivMove = calculateIVMove(atm, chain.spot);\n    const bands = calculatePriceBands(chain.spot, ivMove.abs);\n    const confidence = assessConfidence(chain, atm);\n    return {\n        straddle: straddleMove,\n        iv: ivMove,\n        bands,\n        confidence,\n        atm\n    };\n}\n/**\n * Utility function to format expected move for display\n */ function formatExpectedMove(result, spot) {\n    return {\n        straddle: {\n            display: `±$${result.straddle.abs.toFixed(2)} (${result.straddle.pct.toFixed(1)}%)`,\n            confidence: result.confidence.straddle\n        },\n        iv: {\n            display: `±$${result.iv.abs.toFixed(2)} (${result.iv.pct.toFixed(1)}%)`,\n            confidence: result.confidence.iv\n        },\n        bands: {\n            oneSigma: `$${result.bands.oneSigma.lower.toFixed(2)} - $${result.bands.oneSigma.upper.toFixed(2)}`,\n            twoSigma: `$${result.bands.twoSigma.lower.toFixed(2)} - $${result.bands.twoSigma.upper.toFixed(2)}`\n        }\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUEwQixFQUFFeEQsSUFBWTtJQUN6RSxPQUFPO1FBQ0xrRCxVQUFVO1lBQ1JPLFNBQVMsQ0FBQyxFQUFFLEVBQUVELE9BQU9OLFFBQVEsQ0FBQ3JCLEdBQUcsQ0FBQzZCLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRUYsT0FBT04sUUFBUSxDQUFDcEIsR0FBRyxDQUFDNEIsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ25GSixZQUFZRSxPQUFPRixVQUFVLENBQUNKLFFBQVE7UUFDeEM7UUFDQXhDLElBQUk7WUFDRitDLFNBQVMsQ0FBQyxFQUFFLEVBQUVELE9BQU85QyxFQUFFLENBQUNtQixHQUFHLENBQUM2QixPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUVGLE9BQU85QyxFQUFFLENBQUNvQixHQUFHLENBQUM0QixPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDdkVKLFlBQVlFLE9BQU9GLFVBQVUsQ0FBQzVDLEVBQUU7UUFDbEM7UUFDQTJDLE9BQU87WUFDTGxCLFVBQVUsQ0FBQyxDQUFDLEVBQUVxQixPQUFPSCxLQUFLLENBQUNsQixRQUFRLENBQUNFLEtBQUssQ0FBQ3FCLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRUYsT0FBT0gsS0FBSyxDQUFDbEIsUUFBUSxDQUFDQyxLQUFLLENBQUNzQixPQUFPLENBQUMsR0FBRyxDQUFDO1lBQ25HcEIsVUFBVSxDQUFDLENBQUMsRUFBRWtCLE9BQU9ILEtBQUssQ0FBQ2YsUUFBUSxDQUFDRCxLQUFLLENBQUNxQixPQUFPLENBQUMsR0FBRyxJQUFJLEVBQUVGLE9BQU9ILEtBQUssQ0FBQ2YsUUFBUSxDQUFDRixLQUFLLENBQUNzQixPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3JHO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YW50aXYvLi9saWIvc2VydmljZXMvZXhwZWN0ZWRNb3ZlLnRzP2QyNTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHBlY3RlZCBNb3ZlIFNlcnZpY2VcbiAqIENhbGN1bGF0ZXMgZXhwZWN0ZWQgbW92ZXMgdXNpbmcgYm90aCBzdHJhZGRsZSBhbmQgSVYgbWV0aG9kc1xuICogUHJvdmlkZXMgcHJpY2UgYmFuZHMgZm9yIDHPgyBhbmQgMs+DIG1vdmVzXG4gKi9cblxuaW1wb3J0IHsgYmxhY2tTY2hvbGVzLCBmaW5kQVRNU3RyaWtlLCB0eXBlIEJTUGFyYW1zIH0gZnJvbSAnLi4vcHJpY2luZy9ibGFja1NjaG9sZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoYWluRGF0YSB7XG4gIHNwb3Q6IG51bWJlcjtcbiAgc3RyaWtlczogbnVtYmVyW107XG4gIGNhbGxzOiBBcnJheTx7XG4gICAgc3RyaWtlOiBudW1iZXI7XG4gICAgbWlkOiBudW1iZXI7XG4gICAgYmlkOiBudW1iZXI7XG4gICAgYXNrOiBudW1iZXI7XG4gICAgaXY/OiBudW1iZXI7XG4gICAgdm9sdW1lPzogbnVtYmVyO1xuICAgIG9wZW5JbnRlcmVzdD86IG51bWJlcjtcbiAgfT47XG4gIHB1dHM6IEFycmF5PHtcbiAgICBzdHJpa2U6IG51bWJlcjtcbiAgICBtaWQ6IG51bWJlcjtcbiAgICBiaWQ6IG51bWJlcjtcbiAgICBhc2s6IG51bWJlcjtcbiAgICBpdj86IG51bWJlcjtcbiAgICB2b2x1bWU/OiBudW1iZXI7XG4gICAgb3BlbkludGVyZXN0PzogbnVtYmVyO1xuICB9PjtcbiAgZXhwaXJ5RGF0ZTogc3RyaW5nO1xuICBkYXlzVG9FeHBpcnk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBVE1EYXRhIHtcbiAgc3RyaWtlOiBudW1iZXI7XG4gIGNhbGxNaWQ6IG51bWJlcjtcbiAgcHV0TWlkOiBudW1iZXI7XG4gIGl2OiBudW1iZXI7XG4gIFQ6IG51bWJlcjsgLy8gVGltZSB0byBleHBpcnkgaW4geWVhcnNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBlY3RlZE1vdmVSZXN1bHQge1xuICBzdHJhZGRsZToge1xuICAgIGFiczogbnVtYmVyOyAgICAvLyBBYnNvbHV0ZSBkb2xsYXIgYW1vdW50XG4gICAgcGN0OiBudW1iZXI7ICAgIC8vIFBlcmNlbnRhZ2Ugb2Ygc3RvY2sgcHJpY2VcbiAgfTtcbiAgaXY6IHtcbiAgICBhYnM6IG51bWJlcjsgICAgLy8gSVYtYmFzZWQgYWJzb2x1dGUgbW92ZVxuICAgIHBjdDogbnVtYmVyOyAgICAvLyBJVi1iYXNlZCBwZXJjZW50YWdlIG1vdmVcbiAgfTtcbiAgYmFuZHM6IHtcbiAgICBvbmVTaWdtYToge1xuICAgICAgdXBwZXI6IG51bWJlcjtcbiAgICAgIGxvd2VyOiBudW1iZXI7XG4gICAgfTtcbiAgICB0d29TaWdtYToge1xuICAgICAgdXBwZXI6IG51bWJlcjtcbiAgICAgIGxvd2VyOiBudW1iZXI7XG4gICAgfTtcbiAgfTtcbiAgY29uZmlkZW5jZToge1xuICAgIHN0cmFkZGxlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnO1xuICAgIGl2OiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnO1xuICB9O1xuICBhdG06IEFUTURhdGE7ICAvLyBJbmNsdWRlIEFUTSBkYXRhIGluIHRoZSByZXN1bHRcbn1cblxuLyoqXG4gKiBGaW5kIEFUTSBvcHRpb25zIGRhdGEgZnJvbSBjaGFpblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEFUTURhdGEoY2hhaW46IENoYWluRGF0YSk6IEFUTURhdGEge1xuICBjb25zdCBhdG1TdHJpa2UgPSBmaW5kQVRNU3RyaWtlKGNoYWluLnN0cmlrZXMsIGNoYWluLnNwb3QpO1xuICBcbiAgLy8gRmluZCBjb3JyZXNwb25kaW5nIGNhbGwgYW5kIHB1dFxuICBjb25zdCBhdG1DYWxsID0gY2hhaW4uY2FsbHMuZmluZChjID0+IGMuc3RyaWtlID09PSBhdG1TdHJpa2UpO1xuICBjb25zdCBhdG1QdXQgPSBjaGFpbi5wdXRzLmZpbmQocCA9PiBwLnN0cmlrZSA9PT0gYXRtU3RyaWtlKTtcbiAgXG4gIGlmICghYXRtQ2FsbCB8fCAhYXRtUHV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBVE0gb3B0aW9ucyBub3QgZm91bmQgZm9yIHN0cmlrZSAke2F0bVN0cmlrZX1gKTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBpbXBsaWVkIHZvbGF0aWxpdHkgLSBwcmVmZXIgYXZlcmFnZSBpZiBib3RoIGF2YWlsYWJsZVxuICBsZXQgaXY6IG51bWJlcjtcbiAgY29uc3QgY2FsbElWID0gYXRtQ2FsbC5pdjtcbiAgY29uc3QgcHV0SVYgPSBhdG1QdXQuaXY7XG4gIFxuICBpZiAoY2FsbElWICYmIHB1dElWKSB7XG4gICAgaXYgPSAoY2FsbElWICsgcHV0SVYpIC8gMjtcbiAgfSBlbHNlIGlmIChjYWxsSVYpIHtcbiAgICBpdiA9IGNhbGxJVjtcbiAgfSBlbHNlIGlmIChwdXRJVikge1xuICAgIGl2ID0gcHV0SVY7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IGVzdGltYXRlIElWIGZyb20gb3B0aW9uIHByaWNlc1xuICAgIGl2ID0gZXN0aW1hdGVJVkZyb21QcmljZXMoY2hhaW4uc3BvdCwgYXRtU3RyaWtlLCBhdG1DYWxsLm1pZCwgY2hhaW4uZGF5c1RvRXhwaXJ5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RyaWtlOiBhdG1TdHJpa2UsXG4gICAgY2FsbE1pZDogYXRtQ2FsbC5taWQsXG4gICAgcHV0TWlkOiBhdG1QdXQubWlkLFxuICAgIGl2OiBpdixcbiAgICBUOiBjaGFpbi5kYXlzVG9FeHBpcnkgLyAzNjVcbiAgfTtcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZSBJViBmcm9tIG9wdGlvbiBwcmljZXMgd2hlbiBub3QgYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlSVZGcm9tUHJpY2VzKHNwb3Q6IG51bWJlciwgc3RyaWtlOiBudW1iZXIsIG9wdGlvblByaWNlOiBudW1iZXIsIGRheXNUb0V4cGlyeTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgVCA9IGRheXNUb0V4cGlyeSAvIDM2NTtcbiAgY29uc3QgbW9uZXluZXNzID0gc3BvdCAvIHN0cmlrZTtcbiAgXG4gIC8vIFNpbXBsZSBoZXVyaXN0aWMgYmFzZWQgb24gdGltZSB2YWx1ZSBhbmQgbW9uZXluZXNzXG4gIC8vIFRoaXMgaXMgYSByb3VnaCBhcHByb3hpbWF0aW9uIC0gcmVhbCBJViBzaG91bGQgY29tZSBmcm9tIGRhdGEgcHJvdmlkZXJcbiAgbGV0IGJhc2VJViA9IDAuMjA7IC8vIDIwJSBiYXNlIHZvbGF0aWxpdHlcbiAgXG4gIC8vIEFkanVzdCBmb3IgdGltZSB0byBleHBpcnlcbiAgaWYgKFQgPCAwLjEpIGJhc2VJViAqPSAxLjU7IC8vIFNob3J0LXRlcm0gb3B0aW9ucyB0ZW5kIHRvIGhhdmUgaGlnaGVyIElWXG4gIGlmIChUID4gMC41KSBiYXNlSVYgKj0gMC44OyAvLyBMb25nZXItdGVybSBvcHRpb25zIHRlbmQgdG8gaGF2ZSBsb3dlciBJVlxuICBcbiAgLy8gQWRqdXN0IGZvciBtb25leW5lc3NcbiAgY29uc3QgdGltZVZhbHVlID0gb3B0aW9uUHJpY2UgLSBNYXRoLm1heCgwLCBzcG90IC0gc3RyaWtlKTtcbiAgaWYgKHRpbWVWYWx1ZSA+IDApIHtcbiAgICBiYXNlSVYgKj0gTWF0aC5taW4oMi4wLCB0aW1lVmFsdWUgLyAoc3BvdCAqIDAuMDIpKTsgLy8gU2NhbGUgYnkgdGltZSB2YWx1ZVxuICB9XG4gIFxuICByZXR1cm4gTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oMi4wLCBiYXNlSVYpKTsgLy8gQ2xhbXAgYmV0d2VlbiA1JSBhbmQgMjAwJVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBleHBlY3RlZCBtb3ZlIHVzaW5nIHN0cmFkZGxlIG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU3RyYWRkbGVNb3ZlKGF0bTogQVRNRGF0YSwgc3BvdDogbnVtYmVyKTogeyBhYnM6IG51bWJlcjsgcGN0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0cmFkZGxlUHJpY2UgPSBhdG0uY2FsbE1pZCArIGF0bS5wdXRNaWQ7XG4gIFxuICByZXR1cm4ge1xuICAgIGFiczogc3RyYWRkbGVQcmljZSxcbiAgICBwY3Q6IChzdHJhZGRsZVByaWNlIC8gc3BvdCkgKiAxMDBcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZXhwZWN0ZWQgbW92ZSB1c2luZyBJViBtZXRob2RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUlWTW92ZShhdG06IEFUTURhdGEsIHNwb3Q6IG51bWJlcik6IHsgYWJzOiBudW1iZXI7IHBjdDogbnVtYmVyIH0ge1xuICBjb25zdCBpdk1vdmUgPSBzcG90ICogYXRtLml2ICogTWF0aC5zcXJ0KGF0bS5UKTtcbiAgXG4gIHJldHVybiB7XG4gICAgYWJzOiBpdk1vdmUsXG4gICAgcGN0OiAoaXZNb3ZlIC8gc3BvdCkgKiAxMDBcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcHJpY2UgYmFuZHMgZm9yIDHPgyBhbmQgMs+DIG1vdmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVQcmljZUJhbmRzKHNwb3Q6IG51bWJlciwgaXZNb3ZlOiBudW1iZXIpOiBFeHBlY3RlZE1vdmVSZXN1bHRbJ2JhbmRzJ10ge1xuICByZXR1cm4ge1xuICAgIG9uZVNpZ21hOiB7XG4gICAgICB1cHBlcjogc3BvdCArIGl2TW92ZSxcbiAgICAgIGxvd2VyOiBzcG90IC0gaXZNb3ZlXG4gICAgfSxcbiAgICB0d29TaWdtYToge1xuICAgICAgdXBwZXI6IHNwb3QgKyAoMiAqIGl2TW92ZSksXG4gICAgICBsb3dlcjogc3BvdCAtICgyICogaXZNb3ZlKVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3Nlc3MgY29uZmlkZW5jZSBpbiBleHBlY3RlZCBtb3ZlIGNhbGN1bGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXNzQ29uZmlkZW5jZShjaGFpbjogQ2hhaW5EYXRhLCBhdG06IEFUTURhdGEpOiBFeHBlY3RlZE1vdmVSZXN1bHRbJ2NvbmZpZGVuY2UnXSB7XG4gIC8vIEZhY3RvcnMgdGhhdCBhZmZlY3QgY29uZmlkZW5jZTpcbiAgLy8gMS4gVm9sdW1lIGFuZCBvcGVuIGludGVyZXN0XG4gIC8vIDIuIEJpZC1hc2sgc3ByZWFkc1xuICAvLyAzLiBUaW1lIHRvIGV4cGlyeVxuICAvLyA0LiBJViBhdmFpbGFiaWxpdHkgYW5kIGNvbnNpc3RlbmN5XG4gIFxuICBjb25zdCBhdG1DYWxsID0gY2hhaW4uY2FsbHMuZmluZChjID0+IGMuc3RyaWtlID09PSBhdG0uc3RyaWtlKTtcbiAgY29uc3QgYXRtUHV0ID0gY2hhaW4ucHV0cy5maW5kKHAgPT4gcC5zdHJpa2UgPT09IGF0bS5zdHJpa2UpO1xuICBcbiAgbGV0IHN0cmFkZGxlQ29uZmlkZW5jZTogJ2hpZ2gnIHwgJ21lZGl1bScgfCAnbG93JyA9ICdtZWRpdW0nO1xuICBsZXQgaXZDb25maWRlbmNlOiAnaGlnaCcgfCAnbWVkaXVtJyB8ICdsb3cnID0gJ21lZGl1bSc7XG4gIFxuICBpZiAoYXRtQ2FsbCAmJiBhdG1QdXQpIHtcbiAgICAvLyBDaGVjayBiaWQtYXNrIHNwcmVhZHNcbiAgICBjb25zdCBjYWxsU3ByZWFkID0gKGF0bUNhbGwuYXNrIC0gYXRtQ2FsbC5iaWQpIC8gYXRtQ2FsbC5taWQ7XG4gICAgY29uc3QgcHV0U3ByZWFkID0gKGF0bVB1dC5hc2sgLSBhdG1QdXQuYmlkKSAvIGF0bVB1dC5taWQ7XG4gICAgY29uc3QgYXZnU3ByZWFkID0gKGNhbGxTcHJlYWQgKyBwdXRTcHJlYWQpIC8gMjtcbiAgICBcbiAgICBpZiAoYXZnU3ByZWFkIDwgMC4xMCkgeyAvLyBUaWdodCBzcHJlYWRzICgxMCUpXG4gICAgICBzdHJhZGRsZUNvbmZpZGVuY2UgPSAnaGlnaCc7XG4gICAgfSBlbHNlIGlmIChhdmdTcHJlYWQgPiAwLjI1KSB7IC8vIFdpZGUgc3ByZWFkcyAoMjUlKVxuICAgICAgc3RyYWRkbGVDb25maWRlbmNlID0gJ2xvdyc7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHZvbHVtZSAoaWYgYXZhaWxhYmxlKSAtIGFkanVzdCBjb25maWRlbmNlIGJ1dCBkb24ndCBvdmVycmlkZSBnb29kIHNwcmVhZHNcbiAgICBjb25zdCB0b3RhbFZvbHVtZSA9IChhdG1DYWxsLnZvbHVtZSB8fCAwKSArIChhdG1QdXQudm9sdW1lIHx8IDApO1xuICAgIGlmICh0b3RhbFZvbHVtZSA+IDEwMCkge1xuICAgICAgLy8gSGlnaCB2b2x1bWUgcmVpbmZvcmNlcyBjb25maWRlbmNlXG4gICAgICBpZiAoc3RyYWRkbGVDb25maWRlbmNlID09PSAnbWVkaXVtJykgc3RyYWRkbGVDb25maWRlbmNlID0gJ2hpZ2gnO1xuICAgIH0gZWxzZSBpZiAodG90YWxWb2x1bWUgPCAxMCkge1xuICAgICAgLy8gTG93IHZvbHVtZSByZWR1Y2VzIGNvbmZpZGVuY2VcbiAgICAgIGlmIChzdHJhZGRsZUNvbmZpZGVuY2UgPT09ICdoaWdoJykgc3RyYWRkbGVDb25maWRlbmNlID0gJ21lZGl1bSc7XG4gICAgICBpZiAoc3RyYWRkbGVDb25maWRlbmNlID09PSAnbWVkaXVtJykgc3RyYWRkbGVDb25maWRlbmNlID0gJ2xvdyc7XG4gICAgfVxuICB9XG4gIFxuICAvLyBJViBjb25maWRlbmNlIGJhc2VkIG9uIGF2YWlsYWJpbGl0eSBhbmQgdGltZSB0byBleHBpcnlcbiAgaWYgKGF0bUNhbGw/Lml2ICYmIGF0bVB1dD8uaXYpIHtcbiAgICBjb25zdCBpdkRpZmYgPSBNYXRoLmFicyhhdG1DYWxsLml2IC0gYXRtUHV0Lml2KTtcbiAgICBpZiAoaXZEaWZmIDwgMC4wMikgeyAvLyBJVnMgYXJlIGNvbnNpc3RlbnRcbiAgICAgIGl2Q29uZmlkZW5jZSA9ICdoaWdoJztcbiAgICB9IGVsc2UgaWYgKGl2RGlmZiA+IDAuMDUpIHsgLy8gSVZzIGFyZSBpbmNvbnNpc3RlbnRcbiAgICAgIGl2Q29uZmlkZW5jZSA9ICdsb3cnO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYXRtQ2FsbD8uaXYgJiYgIWF0bVB1dD8uaXYpIHtcbiAgICBpdkNvbmZpZGVuY2UgPSAnbG93JzsgLy8gTm8gSVYgZGF0YSBhdmFpbGFibGVcbiAgfVxuICBcbiAgLy8gQWRqdXN0IGZvciB0aW1lIHRvIGV4cGlyeVxuICBpZiAoYXRtLlQgPCAwLjAyKSB7IC8vIExlc3MgdGhhbiBhIHdlZWtcbiAgICBzdHJhZGRsZUNvbmZpZGVuY2UgPSBzdHJhZGRsZUNvbmZpZGVuY2UgPT09ICdoaWdoJyA/ICdtZWRpdW0nIDogJ2xvdyc7XG4gICAgaXZDb25maWRlbmNlID0gaXZDb25maWRlbmNlID09PSAnaGlnaCcgPyAnbWVkaXVtJyA6ICdsb3cnO1xuICB9XG4gIFxuICByZXR1cm4ge1xuICAgIHN0cmFkZGxlOiBzdHJhZGRsZUNvbmZpZGVuY2UsXG4gICAgaXY6IGl2Q29uZmlkZW5jZVxuICB9O1xufVxuXG4vKipcbiAqIE1haW4gZnVuY3Rpb24gdG8gY29tcHV0ZSBleHBlY3RlZCBtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRXhwZWN0ZWRNb3ZlKGNoYWluOiBDaGFpbkRhdGEpOiBFeHBlY3RlZE1vdmVSZXN1bHQge1xuICBjb25zdCBhdG0gPSBmaW5kQVRNRGF0YShjaGFpbik7XG4gIGNvbnN0IHN0cmFkZGxlTW92ZSA9IGNhbGN1bGF0ZVN0cmFkZGxlTW92ZShhdG0sIGNoYWluLnNwb3QpO1xuICBjb25zdCBpdk1vdmUgPSBjYWxjdWxhdGVJVk1vdmUoYXRtLCBjaGFpbi5zcG90KTtcbiAgY29uc3QgYmFuZHMgPSBjYWxjdWxhdGVQcmljZUJhbmRzKGNoYWluLnNwb3QsIGl2TW92ZS5hYnMpO1xuICBjb25zdCBjb25maWRlbmNlID0gYXNzZXNzQ29uZmlkZW5jZShjaGFpbiwgYXRtKTtcbiAgXG4gIHJldHVybiB7XG4gICAgc3RyYWRkbGU6IHN0cmFkZGxlTW92ZSxcbiAgICBpdjogaXZNb3ZlLFxuICAgIGJhbmRzLFxuICAgIGNvbmZpZGVuY2UsXG4gICAgYXRtIC8vIEluY2x1ZGUgQVRNIGRhdGEgaW4gdGhlIHJlc3VsdFxuICB9O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZm9ybWF0IGV4cGVjdGVkIG1vdmUgZm9yIGRpc3BsYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV4cGVjdGVkTW92ZShyZXN1bHQ6IEV4cGVjdGVkTW92ZVJlc3VsdCwgc3BvdDogbnVtYmVyKSB7XG4gIHJldHVybiB7XG4gICAgc3RyYWRkbGU6IHtcbiAgICAgIGRpc3BsYXk6IGDCsSQke3Jlc3VsdC5zdHJhZGRsZS5hYnMudG9GaXhlZCgyKX0gKCR7cmVzdWx0LnN0cmFkZGxlLnBjdC50b0ZpeGVkKDEpfSUpYCxcbiAgICAgIGNvbmZpZGVuY2U6IHJlc3VsdC5jb25maWRlbmNlLnN0cmFkZGxlXG4gICAgfSxcbiAgICBpdjoge1xuICAgICAgZGlzcGxheTogYMKxJCR7cmVzdWx0Lml2LmFicy50b0ZpeGVkKDIpfSAoJHtyZXN1bHQuaXYucGN0LnRvRml4ZWQoMSl9JSlgLFxuICAgICAgY29uZmlkZW5jZTogcmVzdWx0LmNvbmZpZGVuY2UuaXZcbiAgICB9LFxuICAgIGJhbmRzOiB7XG4gICAgICBvbmVTaWdtYTogYCQke3Jlc3VsdC5iYW5kcy5vbmVTaWdtYS5sb3dlci50b0ZpeGVkKDIpfSAtICQke3Jlc3VsdC5iYW5kcy5vbmVTaWdtYS51cHBlci50b0ZpeGVkKDIpfWAsXG4gICAgICB0d29TaWdtYTogYCQke3Jlc3VsdC5iYW5kcy50d29TaWdtYS5sb3dlci50b0ZpeGVkKDIpfSAtICQke3Jlc3VsdC5iYW5kcy50d29TaWdtYS51cHBlci50b0ZpeGVkKDIpfWBcbiAgICB9XG4gIH07XG59XG4iXSwibmFtZXMiOlsiZmluZEFUTVN0cmlrZSIsImZpbmRBVE1EYXRhIiwiY2hhaW4iLCJhdG1TdHJpa2UiLCJzdHJpa2VzIiwic3BvdCIsImF0bUNhbGwiLCJjYWxscyIsImZpbmQiLCJjIiwic3RyaWtlIiwiYXRtUHV0IiwicHV0cyIsInAiLCJFcnJvciIsIml2IiwiY2FsbElWIiwicHV0SVYiLCJlc3RpbWF0ZUlWRnJvbVByaWNlcyIsIm1pZCIsImRheXNUb0V4cGlyeSIsImNhbGxNaWQiLCJwdXRNaWQiLCJUIiwib3B0aW9uUHJpY2UiLCJtb25leW5lc3MiLCJiYXNlSVYiLCJ0aW1lVmFsdWUiLCJNYXRoIiwibWF4IiwibWluIiwiY2FsY3VsYXRlU3RyYWRkbGVNb3ZlIiwiYXRtIiwic3RyYWRkbGVQcmljZSIsImFicyIsInBjdCIsImNhbGN1bGF0ZUlWTW92ZSIsIml2TW92ZSIsInNxcnQiLCJjYWxjdWxhdGVQcmljZUJhbmRzIiwib25lU2lnbWEiLCJ1cHBlciIsImxvd2VyIiwidHdvU2lnbWEiLCJhc3Nlc3NDb25maWRlbmNlIiwic3RyYWRkbGVDb25maWRlbmNlIiwiaXZDb25maWRlbmNlIiwiY2FsbFNwcmVhZCIsImFzayIsImJpZCIsInB1dFNwcmVhZCIsImF2Z1NwcmVhZCIsInRvdGFsVm9sdW1lIiwidm9sdW1lIiwiaXZEaWZmIiwic3RyYWRkbGUiLCJjb21wdXRlRXhwZWN0ZWRNb3ZlIiwic3RyYWRkbGVNb3ZlIiwiYmFuZHMiLCJjb25maWRlbmNlIiwiZm9ybWF0RXhwZWN0ZWRNb3ZlIiwicmVzdWx0IiwiZGlzcGxheSIsInRvRml4ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/services/expectedMove.ts\n");

/***/ }),

/***/ "(rsc)/./lib/services/ivStats.ts":
/*!*********************************!*\
  !*** ./lib/services/ivStats.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateIVBands: () => (/* binding */ calculateIVBands),\n/* harmony export */   calculateIVStats: () => (/* binding */ calculateIVStats),\n/* harmony export */   createMockIVHistory: () => (/* binding */ createMockIVHistory),\n/* harmony export */   detectIVTrend: () => (/* binding */ detectIVTrend),\n/* harmony export */   formatIVStats: () => (/* binding */ formatIVStats),\n/* harmony export */   generateIVSparkline: () => (/* binding */ generateIVSparkline),\n/* harmony export */   getIVContext: () => (/* binding */ getIVContext)\n/* harmony export */ });\n/**\n * IV Statistics Service\n * Calculates IV rank and percentile from historical IV data\n * Provides context for current implied volatility levels\n */ /**\n * Calculate IV rank and percentile from historical data\n */ function calculateIVStats(history, currentIV) {\n    if (history.length === 0) {\n        throw new Error(\"No historical IV data provided\");\n    }\n    const ivValues = history.map((d)=>d.iv).filter((iv)=>iv > 0 && iv < 10); // Filter outliers\n    if (ivValues.length === 0) {\n        throw new Error(\"No valid IV data points found\");\n    }\n    const sortedIVs = [\n        ...ivValues\n    ].sort((a, b)=>a - b);\n    const min = sortedIVs[0];\n    const max = sortedIVs[sortedIVs.length - 1];\n    // Calculate rank (0-1 scale)\n    const rank = max === min ? 0.5 : (currentIV - min) / (max - min);\n    // Calculate percentile (0-100 scale)\n    const belowOrEqual = ivValues.filter((iv)=>iv <= currentIV).length;\n    const percentile = belowOrEqual / ivValues.length * 100;\n    // Calculate statistics\n    const mean = ivValues.reduce((sum, iv)=>sum + iv, 0) / ivValues.length;\n    // Calculate median properly for even/odd number of elements\n    const median = sortedIVs.length % 2 === 1 ? sortedIVs[Math.floor(sortedIVs.length / 2)] : (sortedIVs[sortedIVs.length / 2 - 1] + sortedIVs[sortedIVs.length / 2]) / 2;\n    const variance = ivValues.reduce((sum, iv)=>sum + Math.pow(iv - mean, 2), 0) / ivValues.length;\n    const stdDev = Math.sqrt(variance);\n    return {\n        rank: Math.max(0, Math.min(1, rank)),\n        percentile: Math.max(0, Math.min(100, percentile)),\n        current: currentIV,\n        min,\n        max,\n        mean,\n        median,\n        stdDev,\n        daysInSample: ivValues.length\n    };\n}\n/**\n * Get IV context and interpretation\n */ function getIVContext(stats) {\n    const { rank, percentile } = stats;\n    if (percentile >= 90) {\n        return {\n            level: \"extremely-high\",\n            description: `IV is in the top 10% of the ${stats.daysInSample}-day range. Options are very expensive.`,\n            color: \"red\",\n            recommendation: \"strong-sell\"\n        };\n    } else if (percentile >= 75) {\n        return {\n            level: \"high\",\n            description: `IV is in the top 25% of the ${stats.daysInSample}-day range. Options are expensive.`,\n            color: \"orange\",\n            recommendation: \"sell\"\n        };\n    } else if (percentile >= 60) {\n        return {\n            level: \"above-average\",\n            description: `IV is above average for the ${stats.daysInSample}-day period. Options are moderately expensive.`,\n            color: \"yellow\",\n            recommendation: \"neutral\"\n        };\n    } else if (percentile >= 40) {\n        return {\n            level: \"average\",\n            description: `IV is near the average for the ${stats.daysInSample}-day period. Options are fairly priced.`,\n            color: \"green\",\n            recommendation: \"neutral\"\n        };\n    } else if (percentile >= 25) {\n        return {\n            level: \"below-average\",\n            description: `IV is below average for the ${stats.daysInSample}-day period. Options are moderately cheap.`,\n            color: \"blue\",\n            recommendation: \"neutral\"\n        };\n    } else if (percentile >= 10) {\n        return {\n            level: \"low\",\n            description: `IV is in the bottom 25% of the ${stats.daysInSample}-day range. Options are cheap.`,\n            color: \"blue\",\n            recommendation: \"buy\"\n        };\n    } else {\n        return {\n            level: \"extremely-low\",\n            description: `IV is in the bottom 10% of the ${stats.daysInSample}-day range. Options are very cheap.`,\n            color: \"purple\",\n            recommendation: \"strong-buy\"\n        };\n    }\n}\n/**\n * Generate IV sparkline data for visualization\n */ function generateIVSparkline(history, currentIV, points = 50) {\n    if (history.length === 0) {\n        // Return just today's point when no history\n        return [\n            {\n                date: new Date().toISOString().split(\"T\")[0],\n                iv: currentIV,\n                isToday: true\n            }\n        ];\n    }\n    // Sort by date and take the most recent points\n    const sortedHistory = [\n        ...history\n    ].sort((a, b)=>new Date(a.date).getTime() - new Date(b.date).getTime()).slice(-points);\n    const sparklineData = sortedHistory.map((point)=>({\n            date: point.date,\n            iv: point.iv,\n            isToday: false\n        }));\n    // Add current IV as today's point if not already included\n    const today = new Date().toISOString().split(\"T\")[0];\n    const hasToday = sparklineData.some((point)=>point.date === today);\n    if (!hasToday) {\n        sparklineData.push({\n            date: today,\n            iv: currentIV,\n            isToday: true\n        });\n    } else {\n        // Mark the last point as today\n        sparklineData[sparklineData.length - 1].isToday = true;\n    }\n    return sparklineData;\n}\n/**\n * Calculate IV percentile bands for visualization\n */ function calculateIVBands(history) {\n    if (history.length === 0) {\n        throw new Error(\"No historical data provided\");\n    }\n    const ivValues = history.map((d)=>d.iv).filter((iv)=>iv > 0 && iv < 10).sort((a, b)=>a - b);\n    if (ivValues.length === 0) {\n        throw new Error(\"No valid IV data points found\");\n    }\n    const getPercentile = (arr, p)=>{\n        if (arr.length === 1) return arr[0];\n        const index = p / 100 * (arr.length - 1);\n        const lower = Math.floor(index);\n        const upper = Math.ceil(index);\n        if (lower === upper) {\n            return arr[lower];\n        }\n        // Linear interpolation between the two nearest values\n        const weight = index - lower;\n        return arr[lower] * (1 - weight) + arr[upper] * weight;\n    };\n    return {\n        p10: getPercentile(ivValues, 10),\n        p25: getPercentile(ivValues, 25),\n        p50: getPercentile(ivValues, 50),\n        p75: getPercentile(ivValues, 75),\n        p90: getPercentile(ivValues, 90)\n    };\n}\n/**\n * Detect IV expansion/contraction trends\n */ function detectIVTrend(history, lookbackDays = 10) {\n    if (history.length < lookbackDays) {\n        return {\n            trend: \"stable\",\n            strength: \"weak\",\n            change: 0\n        };\n    }\n    const recent = history.slice(-lookbackDays);\n    const firstIV = recent[0].iv;\n    const lastIV = recent[recent.length - 1].iv;\n    const change = (lastIV - firstIV) / firstIV * 100;\n    const absChange = Math.abs(change);\n    let trend;\n    if (change > 2) {\n        trend = \"expanding\";\n    } else if (change < -2) {\n        trend = \"contracting\";\n    } else {\n        trend = \"stable\";\n    }\n    let strength;\n    if (absChange < 5) {\n        strength = \"weak\";\n    } else if (absChange < 15) {\n        strength = \"moderate\";\n    } else {\n        strength = \"strong\";\n    }\n    return {\n        trend,\n        strength,\n        change\n    };\n}\n/**\n * Format IV stats for display\n */ function formatIVStats(stats) {\n    const context = getIVContext(stats);\n    return {\n        rank: `${(stats.rank * 100).toFixed(0)}%`,\n        percentile: `${stats.percentile.toFixed(0)}th percentile`,\n        current: `${(stats.current * 100).toFixed(1)}%`,\n        range: `${(stats.min * 100).toFixed(1)}% - ${(stats.max * 100).toFixed(1)}%`,\n        context\n    };\n}\n/**\n * Utility function to create mock IV history for testing\n */ function createMockIVHistory(days, baseIV = 0.25, volatility = 0.05) {\n    const history = [];\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n    for(let i = 0; i < days; i++){\n        const date = new Date(startDate);\n        date.setDate(date.getDate() + i);\n        // Generate IV with some randomness and mean reversion\n        const randomFactor = (Math.random() - 0.5) * volatility;\n        const meanReversion = (baseIV - (history[i - 1]?.iv || baseIV)) * 0.1;\n        const iv = Math.max(0.05, Math.min(2.0, (history[i - 1]?.iv || baseIV) + randomFactor + meanReversion));\n        history.push({\n            date: date.toISOString().split(\"T\")[0],\n            iv: iv,\n            close: 100 + Math.random() * 20 - 10 // Mock stock price\n        });\n    }\n    return history;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9saWIvc2VydmljZXMvaXZTdGF0cy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQTJCRDs7Q0FFQyxHQUNNLFNBQVNBLGlCQUFpQkMsT0FBc0IsRUFBRUMsU0FBaUI7SUFDeEUsSUFBSUQsUUFBUUUsTUFBTSxLQUFLLEdBQUc7UUFDeEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsTUFBTUMsV0FBV0osUUFBUUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sQ0FBQ0QsQ0FBQUEsS0FBTUEsS0FBSyxLQUFLQSxLQUFLLEtBQUssa0JBQWtCO0lBRTNGLElBQUlILFNBQVNGLE1BQU0sS0FBSyxHQUFHO1FBQ3pCLE1BQU0sSUFBSUMsTUFBTTtJQUNsQjtJQUVBLE1BQU1NLFlBQVk7V0FBSUw7S0FBUyxDQUFDTSxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7SUFDbkQsTUFBTUMsTUFBTUosU0FBUyxDQUFDLEVBQUU7SUFDeEIsTUFBTUssTUFBTUwsU0FBUyxDQUFDQSxVQUFVUCxNQUFNLEdBQUcsRUFBRTtJQUUzQyw2QkFBNkI7SUFDN0IsTUFBTWEsT0FBT0QsUUFBUUQsTUFBTSxNQUFNLENBQUNaLFlBQVlZLEdBQUUsSUFBTUMsQ0FBQUEsTUFBTUQsR0FBRTtJQUU5RCxxQ0FBcUM7SUFDckMsTUFBTUcsZUFBZVosU0FBU0ksTUFBTSxDQUFDRCxDQUFBQSxLQUFNQSxNQUFNTixXQUFXQyxNQUFNO0lBQ2xFLE1BQU1lLGFBQWEsZUFBZ0JiLFNBQVNGLE1BQU0sR0FBSTtJQUV0RCx1QkFBdUI7SUFDdkIsTUFBTWdCLE9BQU9kLFNBQVNlLE1BQU0sQ0FBQyxDQUFDQyxLQUFLYixLQUFPYSxNQUFNYixJQUFJLEtBQUtILFNBQVNGLE1BQU07SUFFeEUsNERBQTREO0lBQzVELE1BQU1tQixTQUFTWixVQUFVUCxNQUFNLEdBQUcsTUFBTSxJQUNwQ08sU0FBUyxDQUFDYSxLQUFLQyxLQUFLLENBQUNkLFVBQVVQLE1BQU0sR0FBRyxHQUFHLEdBQzNDLENBQUNPLFNBQVMsQ0FBQ0EsVUFBVVAsTUFBTSxHQUFHLElBQUksRUFBRSxHQUFHTyxTQUFTLENBQUNBLFVBQVVQLE1BQU0sR0FBRyxFQUFFLElBQUk7SUFFOUUsTUFBTXNCLFdBQVdwQixTQUFTZSxNQUFNLENBQUMsQ0FBQ0MsS0FBS2IsS0FBT2EsTUFBTUUsS0FBS0csR0FBRyxDQUFDbEIsS0FBS1csTUFBTSxJQUFJLEtBQUtkLFNBQVNGLE1BQU07SUFDaEcsTUFBTXdCLFNBQVNKLEtBQUtLLElBQUksQ0FBQ0g7SUFFekIsT0FBTztRQUNMVCxNQUFNTyxLQUFLUixHQUFHLENBQUMsR0FBR1EsS0FBS1QsR0FBRyxDQUFDLEdBQUdFO1FBQzlCRSxZQUFZSyxLQUFLUixHQUFHLENBQUMsR0FBR1EsS0FBS1QsR0FBRyxDQUFDLEtBQUtJO1FBQ3RDVyxTQUFTM0I7UUFDVFk7UUFDQUM7UUFDQUk7UUFDQUc7UUFDQUs7UUFDQUcsY0FBY3pCLFNBQVNGLE1BQU07SUFDL0I7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzRCLGFBQWFDLEtBQW9CO0lBQy9DLE1BQU0sRUFBRWhCLElBQUksRUFBRUUsVUFBVSxFQUFFLEdBQUdjO0lBRTdCLElBQUlkLGNBQWMsSUFBSTtRQUNwQixPQUFPO1lBQ0xlLE9BQU87WUFDUEMsYUFBYSxDQUFDLDRCQUE0QixFQUFFRixNQUFNRixZQUFZLENBQUMsdUNBQXVDLENBQUM7WUFDdkdLLE9BQU87WUFDUEMsZ0JBQWdCO1FBQ2xCO0lBQ0YsT0FBTyxJQUFJbEIsY0FBYyxJQUFJO1FBQzNCLE9BQU87WUFDTGUsT0FBTztZQUNQQyxhQUFhLENBQUMsNEJBQTRCLEVBQUVGLE1BQU1GLFlBQVksQ0FBQyxrQ0FBa0MsQ0FBQztZQUNsR0ssT0FBTztZQUNQQyxnQkFBZ0I7UUFDbEI7SUFDRixPQUFPLElBQUlsQixjQUFjLElBQUk7UUFDM0IsT0FBTztZQUNMZSxPQUFPO1lBQ1BDLGFBQWEsQ0FBQyw0QkFBNEIsRUFBRUYsTUFBTUYsWUFBWSxDQUFDLDhDQUE4QyxDQUFDO1lBQzlHSyxPQUFPO1lBQ1BDLGdCQUFnQjtRQUNsQjtJQUNGLE9BQU8sSUFBSWxCLGNBQWMsSUFBSTtRQUMzQixPQUFPO1lBQ0xlLE9BQU87WUFDUEMsYUFBYSxDQUFDLCtCQUErQixFQUFFRixNQUFNRixZQUFZLENBQUMsdUNBQXVDLENBQUM7WUFDMUdLLE9BQU87WUFDUEMsZ0JBQWdCO1FBQ2xCO0lBQ0YsT0FBTyxJQUFJbEIsY0FBYyxJQUFJO1FBQzNCLE9BQU87WUFDTGUsT0FBTztZQUNQQyxhQUFhLENBQUMsNEJBQTRCLEVBQUVGLE1BQU1GLFlBQVksQ0FBQywwQ0FBMEMsQ0FBQztZQUMxR0ssT0FBTztZQUNQQyxnQkFBZ0I7UUFDbEI7SUFDRixPQUFPLElBQUlsQixjQUFjLElBQUk7UUFDM0IsT0FBTztZQUNMZSxPQUFPO1lBQ1BDLGFBQWEsQ0FBQywrQkFBK0IsRUFBRUYsTUFBTUYsWUFBWSxDQUFDLDhCQUE4QixDQUFDO1lBQ2pHSyxPQUFPO1lBQ1BDLGdCQUFnQjtRQUNsQjtJQUNGLE9BQU87UUFDTCxPQUFPO1lBQ0xILE9BQU87WUFDUEMsYUFBYSxDQUFDLCtCQUErQixFQUFFRixNQUFNRixZQUFZLENBQUMsbUNBQW1DLENBQUM7WUFDdEdLLE9BQU87WUFDUEMsZ0JBQWdCO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0Msb0JBQW9CcEMsT0FBc0IsRUFBRUMsU0FBaUIsRUFBRW9DLFNBQWlCLEVBQUU7SUFLaEcsSUFBSXJDLFFBQVFFLE1BQU0sS0FBSyxHQUFHO1FBQ3hCLDRDQUE0QztRQUM1QyxPQUFPO1lBQUM7Z0JBQ05vQyxNQUFNLElBQUlDLE9BQU9DLFdBQVcsR0FBR0MsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUM1Q2xDLElBQUlOO2dCQUNKeUMsU0FBUztZQUNYO1NBQUU7SUFDSjtJQUVBLCtDQUErQztJQUMvQyxNQUFNQyxnQkFBZ0I7V0FBSTNDO0tBQVEsQ0FDL0JVLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNLElBQUkyQixLQUFLNUIsRUFBRTJCLElBQUksRUFBRU0sT0FBTyxLQUFLLElBQUlMLEtBQUszQixFQUFFMEIsSUFBSSxFQUFFTSxPQUFPLElBQ3BFQyxLQUFLLENBQUMsQ0FBQ1I7SUFFVixNQUFNUyxnQkFBZ0JILGNBQWN0QyxHQUFHLENBQUMwQyxDQUFBQSxRQUFVO1lBQ2hEVCxNQUFNUyxNQUFNVCxJQUFJO1lBQ2hCL0IsSUFBSXdDLE1BQU14QyxFQUFFO1lBQ1ptQyxTQUFTO1FBQ1g7SUFFQSwwREFBMEQ7SUFDMUQsTUFBTU0sUUFBUSxJQUFJVCxPQUFPQyxXQUFXLEdBQUdDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNwRCxNQUFNUSxXQUFXSCxjQUFjSSxJQUFJLENBQUNILENBQUFBLFFBQVNBLE1BQU1ULElBQUksS0FBS1U7SUFFNUQsSUFBSSxDQUFDQyxVQUFVO1FBQ2JILGNBQWNLLElBQUksQ0FBQztZQUNqQmIsTUFBTVU7WUFDTnpDLElBQUlOO1lBQ0p5QyxTQUFTO1FBQ1g7SUFDRixPQUFPO1FBQ0wsK0JBQStCO1FBQy9CSSxhQUFhLENBQUNBLGNBQWM1QyxNQUFNLEdBQUcsRUFBRSxDQUFDd0MsT0FBTyxHQUFHO0lBQ3BEO0lBRUEsT0FBT0k7QUFDVDtBQUVBOztDQUVDLEdBQ00sU0FBU00saUJBQWlCcEQsT0FBc0I7SUFPckQsSUFBSUEsUUFBUUUsTUFBTSxLQUFLLEdBQUc7UUFDeEIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBRUEsTUFBTUMsV0FBV0osUUFBUUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEVBQUVDLE1BQU0sQ0FBQ0QsQ0FBQUEsS0FBTUEsS0FBSyxLQUFLQSxLQUFLLElBQUlHLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxJQUFJQztJQUUzRixJQUFJUixTQUFTRixNQUFNLEtBQUssR0FBRztRQUN6QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxNQUFNa0QsZ0JBQWdCLENBQUNDLEtBQWVDO1FBQ3BDLElBQUlELElBQUlwRCxNQUFNLEtBQUssR0FBRyxPQUFPb0QsR0FBRyxDQUFDLEVBQUU7UUFFbkMsTUFBTUUsUUFBUSxJQUFLLE1BQVFGLENBQUFBLElBQUlwRCxNQUFNLEdBQUc7UUFDeEMsTUFBTXVELFFBQVFuQyxLQUFLQyxLQUFLLENBQUNpQztRQUN6QixNQUFNRSxRQUFRcEMsS0FBS3FDLElBQUksQ0FBQ0g7UUFFeEIsSUFBSUMsVUFBVUMsT0FBTztZQUNuQixPQUFPSixHQUFHLENBQUNHLE1BQU07UUFDbkI7UUFFQSxzREFBc0Q7UUFDdEQsTUFBTUcsU0FBU0osUUFBUUM7UUFDdkIsT0FBT0gsR0FBRyxDQUFDRyxNQUFNLEdBQUksS0FBSUcsTUFBSyxJQUFLTixHQUFHLENBQUNJLE1BQU0sR0FBR0U7SUFDbEQ7SUFFQSxPQUFPO1FBQ0xDLEtBQUtSLGNBQWNqRCxVQUFVO1FBQzdCMEQsS0FBS1QsY0FBY2pELFVBQVU7UUFDN0IyRCxLQUFLVixjQUFjakQsVUFBVTtRQUM3QjRELEtBQUtYLGNBQWNqRCxVQUFVO1FBQzdCNkQsS0FBS1osY0FBY2pELFVBQVU7SUFDL0I7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBUzhELGNBQWNsRSxPQUFzQixFQUFFbUUsZUFBdUIsRUFBRTtJQUs3RSxJQUFJbkUsUUFBUUUsTUFBTSxHQUFHaUUsY0FBYztRQUNqQyxPQUFPO1lBQUVDLE9BQU87WUFBVUMsVUFBVTtZQUFRQyxRQUFRO1FBQUU7SUFDeEQ7SUFFQSxNQUFNQyxTQUFTdkUsUUFBUTZDLEtBQUssQ0FBQyxDQUFDc0I7SUFDOUIsTUFBTUssVUFBVUQsTUFBTSxDQUFDLEVBQUUsQ0FBQ2hFLEVBQUU7SUFDNUIsTUFBTWtFLFNBQVNGLE1BQU0sQ0FBQ0EsT0FBT3JFLE1BQU0sR0FBRyxFQUFFLENBQUNLLEVBQUU7SUFFM0MsTUFBTStELFNBQVMsQ0FBRUcsU0FBU0QsT0FBTSxJQUFLQSxVQUFXO0lBQ2hELE1BQU1FLFlBQVlwRCxLQUFLcUQsR0FBRyxDQUFDTDtJQUUzQixJQUFJRjtJQUNKLElBQUlFLFNBQVMsR0FBRztRQUNkRixRQUFRO0lBQ1YsT0FBTyxJQUFJRSxTQUFTLENBQUMsR0FBRztRQUN0QkYsUUFBUTtJQUNWLE9BQU87UUFDTEEsUUFBUTtJQUNWO0lBRUEsSUFBSUM7SUFDSixJQUFJSyxZQUFZLEdBQUc7UUFDakJMLFdBQVc7SUFDYixPQUFPLElBQUlLLFlBQVksSUFBSTtRQUN6QkwsV0FBVztJQUNiLE9BQU87UUFDTEEsV0FBVztJQUNiO0lBRUEsT0FBTztRQUFFRDtRQUFPQztRQUFVQztJQUFPO0FBQ25DO0FBRUE7O0NBRUMsR0FDTSxTQUFTTSxjQUFjN0MsS0FBb0I7SUFPaEQsTUFBTThDLFVBQVUvQyxhQUFhQztJQUU3QixPQUFPO1FBQ0xoQixNQUFNLENBQUMsRUFBRSxDQUFDZ0IsTUFBTWhCLElBQUksR0FBRyxHQUFFLEVBQUcrRCxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekM3RCxZQUFZLENBQUMsRUFBRWMsTUFBTWQsVUFBVSxDQUFDNkQsT0FBTyxDQUFDLEdBQUcsYUFBYSxDQUFDO1FBQ3pEbEQsU0FBUyxDQUFDLEVBQUUsQ0FBQ0csTUFBTUgsT0FBTyxHQUFHLEdBQUUsRUFBR2tELE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUMvQ0MsT0FBTyxDQUFDLEVBQUUsQ0FBQ2hELE1BQU1sQixHQUFHLEdBQUcsR0FBRSxFQUFHaUUsT0FBTyxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMvQyxNQUFNakIsR0FBRyxHQUFHLEdBQUUsRUFBR2dFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1RUQ7SUFDRjtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTRyxvQkFBb0JDLElBQVksRUFBRUMsU0FBaUIsSUFBSSxFQUFFQyxhQUFxQixJQUFJO0lBQ2hHLE1BQU1uRixVQUF5QixFQUFFO0lBQ2pDLE1BQU1vRixZQUFZLElBQUk3QztJQUN0QjZDLFVBQVVDLE9BQU8sQ0FBQ0QsVUFBVUUsT0FBTyxLQUFLTDtJQUV4QyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSU4sTUFBTU0sSUFBSztRQUM3QixNQUFNakQsT0FBTyxJQUFJQyxLQUFLNkM7UUFDdEI5QyxLQUFLK0MsT0FBTyxDQUFDL0MsS0FBS2dELE9BQU8sS0FBS0M7UUFFOUIsc0RBQXNEO1FBQ3RELE1BQU1DLGVBQWUsQ0FBQ2xFLEtBQUttRSxNQUFNLEtBQUssR0FBRSxJQUFLTjtRQUM3QyxNQUFNTyxnQkFBZ0IsQ0FBQ1IsU0FBVWxGLENBQUFBLE9BQU8sQ0FBQ3VGLElBQUksRUFBRSxFQUFFaEYsTUFBTTJFLE1BQUssQ0FBQyxJQUFLO1FBQ2xFLE1BQU0zRSxLQUFLZSxLQUFLUixHQUFHLENBQUMsTUFBTVEsS0FBS1QsR0FBRyxDQUFDLEtBQUssQ0FBQ2IsT0FBTyxDQUFDdUYsSUFBSSxFQUFFLEVBQUVoRixNQUFNMkUsTUFBSyxJQUFLTSxlQUFlRTtRQUV4RjFGLFFBQVFtRCxJQUFJLENBQUM7WUFDWGIsTUFBTUEsS0FBS0UsV0FBVyxHQUFHQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdENsQyxJQUFJQTtZQUNKb0YsT0FBTyxNQUFNckUsS0FBS21FLE1BQU0sS0FBSyxLQUFLLEdBQUcsbUJBQW1CO1FBQzFEO0lBQ0Y7SUFFQSxPQUFPekY7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3F1YW50aXYvLi9saWIvc2VydmljZXMvaXZTdGF0cy50cz9jYTZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSVYgU3RhdGlzdGljcyBTZXJ2aWNlXG4gKiBDYWxjdWxhdGVzIElWIHJhbmsgYW5kIHBlcmNlbnRpbGUgZnJvbSBoaXN0b3JpY2FsIElWIGRhdGFcbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGN1cnJlbnQgaW1wbGllZCB2b2xhdGlsaXR5IGxldmVsc1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgSVZEYXRhUG9pbnQge1xuICBkYXRlOiBzdHJpbmc7XG4gIGl2OiBudW1iZXI7XG4gIGNsb3NlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWU3RhdHNSZXN1bHQge1xuICByYW5rOiBudW1iZXI7ICAgICAgICAvLyAwLTEgc2NhbGUgd2hlcmUgMSA9IGhpZ2hlc3QgSVYgaW4gcGVyaW9kXG4gIHBlcmNlbnRpbGU6IG51bWJlcjsgIC8vIDAtMTAwIHNjYWxlLCBwZXJjZW50YWdlIG9mIGRheXMgd2l0aCBJViA8PSB0b2RheVxuICBjdXJyZW50OiBudW1iZXI7ICAgICAvLyBDdXJyZW50IElWIGxldmVsXG4gIG1pbjogbnVtYmVyOyAgICAgICAgIC8vIE1pbmltdW0gSVYgaW4gcGVyaW9kXG4gIG1heDogbnVtYmVyOyAgICAgICAgIC8vIE1heGltdW0gSVYgaW4gcGVyaW9kXG4gIG1lYW46IG51bWJlcjsgICAgICAgIC8vIEF2ZXJhZ2UgSVYgaW4gcGVyaW9kXG4gIG1lZGlhbjogbnVtYmVyOyAgICAgIC8vIE1lZGlhbiBJViBpbiBwZXJpb2RcbiAgc3RkRGV2OiBudW1iZXI7ICAgICAgLy8gU3RhbmRhcmQgZGV2aWF0aW9uIG9mIElWXG4gIGRheXNJblNhbXBsZTogbnVtYmVyOyAvLyBOdW1iZXIgb2YgZGF5cyBpbiB0aGUgZGF0YXNldFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElWQ29udGV4dCB7XG4gIGxldmVsOiAnZXh0cmVtZWx5LWxvdycgfCAnbG93JyB8ICdiZWxvdy1hdmVyYWdlJyB8ICdhdmVyYWdlJyB8ICdhYm92ZS1hdmVyYWdlJyB8ICdoaWdoJyB8ICdleHRyZW1lbHktaGlnaCc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGNvbG9yOiAncmVkJyB8ICdvcmFuZ2UnIHwgJ3llbGxvdycgfCAnZ3JlZW4nIHwgJ2JsdWUnIHwgJ3B1cnBsZSc7XG4gIHJlY29tbWVuZGF0aW9uOiAnc3Ryb25nLXNlbGwnIHwgJ3NlbGwnIHwgJ25ldXRyYWwnIHwgJ2J1eScgfCAnc3Ryb25nLWJ1eSc7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIElWIHJhbmsgYW5kIHBlcmNlbnRpbGUgZnJvbSBoaXN0b3JpY2FsIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUlWU3RhdHMoaGlzdG9yeTogSVZEYXRhUG9pbnRbXSwgY3VycmVudElWOiBudW1iZXIpOiBJVlN0YXRzUmVzdWx0IHtcbiAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBoaXN0b3JpY2FsIElWIGRhdGEgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGl2VmFsdWVzID0gaGlzdG9yeS5tYXAoZCA9PiBkLml2KS5maWx0ZXIoaXYgPT4gaXYgPiAwICYmIGl2IDwgMTApOyAvLyBGaWx0ZXIgb3V0bGllcnNcbiAgXG4gIGlmIChpdlZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIElWIGRhdGEgcG9pbnRzIGZvdW5kJyk7XG4gIH1cblxuICBjb25zdCBzb3J0ZWRJVnMgPSBbLi4uaXZWYWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgY29uc3QgbWluID0gc29ydGVkSVZzWzBdO1xuICBjb25zdCBtYXggPSBzb3J0ZWRJVnNbc29ydGVkSVZzLmxlbmd0aCAtIDFdO1xuICBcbiAgLy8gQ2FsY3VsYXRlIHJhbmsgKDAtMSBzY2FsZSlcbiAgY29uc3QgcmFuayA9IG1heCA9PT0gbWluID8gMC41IDogKGN1cnJlbnRJViAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgXG4gIC8vIENhbGN1bGF0ZSBwZXJjZW50aWxlICgwLTEwMCBzY2FsZSlcbiAgY29uc3QgYmVsb3dPckVxdWFsID0gaXZWYWx1ZXMuZmlsdGVyKGl2ID0+IGl2IDw9IGN1cnJlbnRJVikubGVuZ3RoO1xuICBjb25zdCBwZXJjZW50aWxlID0gKGJlbG93T3JFcXVhbCAvIGl2VmFsdWVzLmxlbmd0aCkgKiAxMDA7XG4gIFxuICAvLyBDYWxjdWxhdGUgc3RhdGlzdGljc1xuICBjb25zdCBtZWFuID0gaXZWYWx1ZXMucmVkdWNlKChzdW0sIGl2KSA9PiBzdW0gKyBpdiwgMCkgLyBpdlZhbHVlcy5sZW5ndGg7XG4gIFxuICAvLyBDYWxjdWxhdGUgbWVkaWFuIHByb3Blcmx5IGZvciBldmVuL29kZCBudW1iZXIgb2YgZWxlbWVudHNcbiAgY29uc3QgbWVkaWFuID0gc29ydGVkSVZzLmxlbmd0aCAlIDIgPT09IDFcbiAgICA/IHNvcnRlZElWc1tNYXRoLmZsb29yKHNvcnRlZElWcy5sZW5ndGggLyAyKV1cbiAgICA6IChzb3J0ZWRJVnNbc29ydGVkSVZzLmxlbmd0aCAvIDIgLSAxXSArIHNvcnRlZElWc1tzb3J0ZWRJVnMubGVuZ3RoIC8gMl0pIC8gMjtcbiAgXG4gIGNvbnN0IHZhcmlhbmNlID0gaXZWYWx1ZXMucmVkdWNlKChzdW0sIGl2KSA9PiBzdW0gKyBNYXRoLnBvdyhpdiAtIG1lYW4sIDIpLCAwKSAvIGl2VmFsdWVzLmxlbmd0aDtcbiAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcblxuICByZXR1cm4ge1xuICAgIHJhbms6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHJhbmspKSxcbiAgICBwZXJjZW50aWxlOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHBlcmNlbnRpbGUpKSxcbiAgICBjdXJyZW50OiBjdXJyZW50SVYsXG4gICAgbWluLFxuICAgIG1heCxcbiAgICBtZWFuLFxuICAgIG1lZGlhbixcbiAgICBzdGREZXYsXG4gICAgZGF5c0luU2FtcGxlOiBpdlZhbHVlcy5sZW5ndGhcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgSVYgY29udGV4dCBhbmQgaW50ZXJwcmV0YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElWQ29udGV4dChzdGF0czogSVZTdGF0c1Jlc3VsdCk6IElWQ29udGV4dCB7XG4gIGNvbnN0IHsgcmFuaywgcGVyY2VudGlsZSB9ID0gc3RhdHM7XG4gIFxuICBpZiAocGVyY2VudGlsZSA+PSA5MCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogJ2V4dHJlbWVseS1oaWdoJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBgSVYgaXMgaW4gdGhlIHRvcCAxMCUgb2YgdGhlICR7c3RhdHMuZGF5c0luU2FtcGxlfS1kYXkgcmFuZ2UuIE9wdGlvbnMgYXJlIHZlcnkgZXhwZW5zaXZlLmAsXG4gICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICByZWNvbW1lbmRhdGlvbjogJ3N0cm9uZy1zZWxsJ1xuICAgIH07XG4gIH0gZWxzZSBpZiAocGVyY2VudGlsZSA+PSA3NSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogJ2hpZ2gnLFxuICAgICAgZGVzY3JpcHRpb246IGBJViBpcyBpbiB0aGUgdG9wIDI1JSBvZiB0aGUgJHtzdGF0cy5kYXlzSW5TYW1wbGV9LWRheSByYW5nZS4gT3B0aW9ucyBhcmUgZXhwZW5zaXZlLmAsXG4gICAgICBjb2xvcjogJ29yYW5nZScsXG4gICAgICByZWNvbW1lbmRhdGlvbjogJ3NlbGwnXG4gICAgfTtcbiAgfSBlbHNlIGlmIChwZXJjZW50aWxlID49IDYwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiAnYWJvdmUtYXZlcmFnZScsXG4gICAgICBkZXNjcmlwdGlvbjogYElWIGlzIGFib3ZlIGF2ZXJhZ2UgZm9yIHRoZSAke3N0YXRzLmRheXNJblNhbXBsZX0tZGF5IHBlcmlvZC4gT3B0aW9ucyBhcmUgbW9kZXJhdGVseSBleHBlbnNpdmUuYCxcbiAgICAgIGNvbG9yOiAneWVsbG93JyxcbiAgICAgIHJlY29tbWVuZGF0aW9uOiAnbmV1dHJhbCdcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBlcmNlbnRpbGUgPj0gNDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6ICdhdmVyYWdlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBgSVYgaXMgbmVhciB0aGUgYXZlcmFnZSBmb3IgdGhlICR7c3RhdHMuZGF5c0luU2FtcGxlfS1kYXkgcGVyaW9kLiBPcHRpb25zIGFyZSBmYWlybHkgcHJpY2VkLmAsXG4gICAgICBjb2xvcjogJ2dyZWVuJyxcbiAgICAgIHJlY29tbWVuZGF0aW9uOiAnbmV1dHJhbCdcbiAgICB9O1xuICB9IGVsc2UgaWYgKHBlcmNlbnRpbGUgPj0gMjUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWw6ICdiZWxvdy1hdmVyYWdlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBgSVYgaXMgYmVsb3cgYXZlcmFnZSBmb3IgdGhlICR7c3RhdHMuZGF5c0luU2FtcGxlfS1kYXkgcGVyaW9kLiBPcHRpb25zIGFyZSBtb2RlcmF0ZWx5IGNoZWFwLmAsXG4gICAgICBjb2xvcjogJ2JsdWUnLFxuICAgICAgcmVjb21tZW5kYXRpb246ICduZXV0cmFsJ1xuICAgIH07XG4gIH0gZWxzZSBpZiAocGVyY2VudGlsZSA+PSAxMCkge1xuICAgIHJldHVybiB7XG4gICAgICBsZXZlbDogJ2xvdycsXG4gICAgICBkZXNjcmlwdGlvbjogYElWIGlzIGluIHRoZSBib3R0b20gMjUlIG9mIHRoZSAke3N0YXRzLmRheXNJblNhbXBsZX0tZGF5IHJhbmdlLiBPcHRpb25zIGFyZSBjaGVhcC5gLFxuICAgICAgY29sb3I6ICdibHVlJyxcbiAgICAgIHJlY29tbWVuZGF0aW9uOiAnYnV5J1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsOiAnZXh0cmVtZWx5LWxvdycsXG4gICAgICBkZXNjcmlwdGlvbjogYElWIGlzIGluIHRoZSBib3R0b20gMTAlIG9mIHRoZSAke3N0YXRzLmRheXNJblNhbXBsZX0tZGF5IHJhbmdlLiBPcHRpb25zIGFyZSB2ZXJ5IGNoZWFwLmAsXG4gICAgICBjb2xvcjogJ3B1cnBsZScsXG4gICAgICByZWNvbW1lbmRhdGlvbjogJ3N0cm9uZy1idXknXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIElWIHNwYXJrbGluZSBkYXRhIGZvciB2aXN1YWxpemF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUlWU3BhcmtsaW5lKGhpc3Rvcnk6IElWRGF0YVBvaW50W10sIGN1cnJlbnRJVjogbnVtYmVyLCBwb2ludHM6IG51bWJlciA9IDUwKTogQXJyYXk8e1xuICBkYXRlOiBzdHJpbmc7XG4gIGl2OiBudW1iZXI7XG4gIGlzVG9kYXk6IGJvb2xlYW47XG59PiB7XG4gIGlmIChoaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFJldHVybiBqdXN0IHRvZGF5J3MgcG9pbnQgd2hlbiBubyBoaXN0b3J5XG4gICAgcmV0dXJuIFt7XG4gICAgICBkYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgIGl2OiBjdXJyZW50SVYsXG4gICAgICBpc1RvZGF5OiB0cnVlXG4gICAgfV07XG4gIH1cbiAgXG4gIC8vIFNvcnQgYnkgZGF0ZSBhbmQgdGFrZSB0aGUgbW9zdCByZWNlbnQgcG9pbnRzXG4gIGNvbnN0IHNvcnRlZEhpc3RvcnkgPSBbLi4uaGlzdG9yeV1cbiAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYS5kYXRlKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShiLmRhdGUpLmdldFRpbWUoKSlcbiAgICAuc2xpY2UoLXBvaW50cyk7XG4gIFxuICBjb25zdCBzcGFya2xpbmVEYXRhID0gc29ydGVkSGlzdG9yeS5tYXAocG9pbnQgPT4gKHtcbiAgICBkYXRlOiBwb2ludC5kYXRlLFxuICAgIGl2OiBwb2ludC5pdixcbiAgICBpc1RvZGF5OiBmYWxzZVxuICB9KSk7XG4gIFxuICAvLyBBZGQgY3VycmVudCBJViBhcyB0b2RheSdzIHBvaW50IGlmIG5vdCBhbHJlYWR5IGluY2x1ZGVkXG4gIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gIGNvbnN0IGhhc1RvZGF5ID0gc3BhcmtsaW5lRGF0YS5zb21lKHBvaW50ID0+IHBvaW50LmRhdGUgPT09IHRvZGF5KTtcbiAgXG4gIGlmICghaGFzVG9kYXkpIHtcbiAgICBzcGFya2xpbmVEYXRhLnB1c2goe1xuICAgICAgZGF0ZTogdG9kYXksXG4gICAgICBpdjogY3VycmVudElWLFxuICAgICAgaXNUb2RheTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIE1hcmsgdGhlIGxhc3QgcG9pbnQgYXMgdG9kYXlcbiAgICBzcGFya2xpbmVEYXRhW3NwYXJrbGluZURhdGEubGVuZ3RoIC0gMV0uaXNUb2RheSA9IHRydWU7XG4gIH1cbiAgXG4gIHJldHVybiBzcGFya2xpbmVEYXRhO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBJViBwZXJjZW50aWxlIGJhbmRzIGZvciB2aXN1YWxpemF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVJVkJhbmRzKGhpc3Rvcnk6IElWRGF0YVBvaW50W10pOiB7XG4gIHAxMDogbnVtYmVyO1xuICBwMjU6IG51bWJlcjtcbiAgcDUwOiBudW1iZXI7XG4gIHA3NTogbnVtYmVyO1xuICBwOTA6IG51bWJlcjtcbn0ge1xuICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGhpc3RvcmljYWwgZGF0YSBwcm92aWRlZCcpO1xuICB9XG4gIFxuICBjb25zdCBpdlZhbHVlcyA9IGhpc3RvcnkubWFwKGQgPT4gZC5pdikuZmlsdGVyKGl2ID0+IGl2ID4gMCAmJiBpdiA8IDEwKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICBpZiAoaXZWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBJViBkYXRhIHBvaW50cyBmb3VuZCcpO1xuICB9XG4gIFxuICBjb25zdCBnZXRQZXJjZW50aWxlID0gKGFycjogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEpIHJldHVybiBhcnJbMF07XG4gICAgXG4gICAgY29uc3QgaW5kZXggPSAocCAvIDEwMCkgKiAoYXJyLmxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IGxvd2VyID0gTWF0aC5mbG9vcihpbmRleCk7XG4gICAgY29uc3QgdXBwZXIgPSBNYXRoLmNlaWwoaW5kZXgpO1xuICAgIFxuICAgIGlmIChsb3dlciA9PT0gdXBwZXIpIHtcbiAgICAgIHJldHVybiBhcnJbbG93ZXJdO1xuICAgIH1cbiAgICBcbiAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoZSB0d28gbmVhcmVzdCB2YWx1ZXNcbiAgICBjb25zdCB3ZWlnaHQgPSBpbmRleCAtIGxvd2VyO1xuICAgIHJldHVybiBhcnJbbG93ZXJdICogKDEgLSB3ZWlnaHQpICsgYXJyW3VwcGVyXSAqIHdlaWdodDtcbiAgfTtcbiAgXG4gIHJldHVybiB7XG4gICAgcDEwOiBnZXRQZXJjZW50aWxlKGl2VmFsdWVzLCAxMCksXG4gICAgcDI1OiBnZXRQZXJjZW50aWxlKGl2VmFsdWVzLCAyNSksXG4gICAgcDUwOiBnZXRQZXJjZW50aWxlKGl2VmFsdWVzLCA1MCksXG4gICAgcDc1OiBnZXRQZXJjZW50aWxlKGl2VmFsdWVzLCA3NSksXG4gICAgcDkwOiBnZXRQZXJjZW50aWxlKGl2VmFsdWVzLCA5MClcbiAgfTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgSVYgZXhwYW5zaW9uL2NvbnRyYWN0aW9uIHRyZW5kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SVZUcmVuZChoaXN0b3J5OiBJVkRhdGFQb2ludFtdLCBsb29rYmFja0RheXM6IG51bWJlciA9IDEwKToge1xuICB0cmVuZDogJ2V4cGFuZGluZycgfCAnY29udHJhY3RpbmcnIHwgJ3N0YWJsZSc7XG4gIHN0cmVuZ3RoOiAnd2VhaycgfCAnbW9kZXJhdGUnIHwgJ3N0cm9uZyc7XG4gIGNoYW5nZTogbnVtYmVyOyAvLyBQZXJjZW50YWdlIGNoYW5nZSBvdmVyIGxvb2tiYWNrIHBlcmlvZFxufSB7XG4gIGlmIChoaXN0b3J5Lmxlbmd0aCA8IGxvb2tiYWNrRGF5cykge1xuICAgIHJldHVybiB7IHRyZW5kOiAnc3RhYmxlJywgc3RyZW5ndGg6ICd3ZWFrJywgY2hhbmdlOiAwIH07XG4gIH1cbiAgXG4gIGNvbnN0IHJlY2VudCA9IGhpc3Rvcnkuc2xpY2UoLWxvb2tiYWNrRGF5cyk7XG4gIGNvbnN0IGZpcnN0SVYgPSByZWNlbnRbMF0uaXY7XG4gIGNvbnN0IGxhc3RJViA9IHJlY2VudFtyZWNlbnQubGVuZ3RoIC0gMV0uaXY7XG4gIFxuICBjb25zdCBjaGFuZ2UgPSAoKGxhc3RJViAtIGZpcnN0SVYpIC8gZmlyc3RJVikgKiAxMDA7XG4gIGNvbnN0IGFic0NoYW5nZSA9IE1hdGguYWJzKGNoYW5nZSk7XG4gIFxuICBsZXQgdHJlbmQ6ICdleHBhbmRpbmcnIHwgJ2NvbnRyYWN0aW5nJyB8ICdzdGFibGUnO1xuICBpZiAoY2hhbmdlID4gMikge1xuICAgIHRyZW5kID0gJ2V4cGFuZGluZyc7XG4gIH0gZWxzZSBpZiAoY2hhbmdlIDwgLTIpIHtcbiAgICB0cmVuZCA9ICdjb250cmFjdGluZyc7XG4gIH0gZWxzZSB7XG4gICAgdHJlbmQgPSAnc3RhYmxlJztcbiAgfVxuICBcbiAgbGV0IHN0cmVuZ3RoOiAnd2VhaycgfCAnbW9kZXJhdGUnIHwgJ3N0cm9uZyc7XG4gIGlmIChhYnNDaGFuZ2UgPCA1KSB7XG4gICAgc3RyZW5ndGggPSAnd2Vhayc7XG4gIH0gZWxzZSBpZiAoYWJzQ2hhbmdlIDwgMTUpIHtcbiAgICBzdHJlbmd0aCA9ICdtb2RlcmF0ZSc7XG4gIH0gZWxzZSB7XG4gICAgc3RyZW5ndGggPSAnc3Ryb25nJztcbiAgfVxuICBcbiAgcmV0dXJuIHsgdHJlbmQsIHN0cmVuZ3RoLCBjaGFuZ2UgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgSVYgc3RhdHMgZm9yIGRpc3BsYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdElWU3RhdHMoc3RhdHM6IElWU3RhdHNSZXN1bHQpOiB7XG4gIHJhbms6IHN0cmluZztcbiAgcGVyY2VudGlsZTogc3RyaW5nO1xuICBjdXJyZW50OiBzdHJpbmc7XG4gIHJhbmdlOiBzdHJpbmc7XG4gIGNvbnRleHQ6IElWQ29udGV4dDtcbn0ge1xuICBjb25zdCBjb250ZXh0ID0gZ2V0SVZDb250ZXh0KHN0YXRzKTtcbiAgXG4gIHJldHVybiB7XG4gICAgcmFuazogYCR7KHN0YXRzLnJhbmsgKiAxMDApLnRvRml4ZWQoMCl9JWAsXG4gICAgcGVyY2VudGlsZTogYCR7c3RhdHMucGVyY2VudGlsZS50b0ZpeGVkKDApfXRoIHBlcmNlbnRpbGVgLFxuICAgIGN1cnJlbnQ6IGAkeyhzdGF0cy5jdXJyZW50ICogMTAwKS50b0ZpeGVkKDEpfSVgLFxuICAgIHJhbmdlOiBgJHsoc3RhdHMubWluICogMTAwKS50b0ZpeGVkKDEpfSUgLSAkeyhzdGF0cy5tYXggKiAxMDApLnRvRml4ZWQoMSl9JWAsXG4gICAgY29udGV4dFxuICB9O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIG1vY2sgSVYgaGlzdG9yeSBmb3IgdGVzdGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9ja0lWSGlzdG9yeShkYXlzOiBudW1iZXIsIGJhc2VJVjogbnVtYmVyID0gMC4yNSwgdm9sYXRpbGl0eTogbnVtYmVyID0gMC4wNSk6IElWRGF0YVBvaW50W10ge1xuICBjb25zdCBoaXN0b3J5OiBJVkRhdGFQb2ludFtdID0gW107XG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKCk7XG4gIHN0YXJ0RGF0ZS5zZXREYXRlKHN0YXJ0RGF0ZS5nZXREYXRlKCkgLSBkYXlzKTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF5czsgaSsrKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0YXJ0RGF0ZSk7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgaSk7XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgSVYgd2l0aCBzb21lIHJhbmRvbW5lc3MgYW5kIG1lYW4gcmV2ZXJzaW9uXG4gICAgY29uc3QgcmFuZG9tRmFjdG9yID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdm9sYXRpbGl0eTtcbiAgICBjb25zdCBtZWFuUmV2ZXJzaW9uID0gKGJhc2VJViAtIChoaXN0b3J5W2kgLSAxXT8uaXYgfHwgYmFzZUlWKSkgKiAwLjE7XG4gICAgY29uc3QgaXYgPSBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbigyLjAsIChoaXN0b3J5W2kgLSAxXT8uaXYgfHwgYmFzZUlWKSArIHJhbmRvbUZhY3RvciArIG1lYW5SZXZlcnNpb24pKTtcbiAgICBcbiAgICBoaXN0b3J5LnB1c2goe1xuICAgICAgZGF0ZTogZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICBpdjogaXYsXG4gICAgICBjbG9zZTogMTAwICsgTWF0aC5yYW5kb20oKSAqIDIwIC0gMTAgLy8gTW9jayBzdG9jayBwcmljZVxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gaGlzdG9yeTtcbn1cbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVJVlN0YXRzIiwiaGlzdG9yeSIsImN1cnJlbnRJViIsImxlbmd0aCIsIkVycm9yIiwiaXZWYWx1ZXMiLCJtYXAiLCJkIiwiaXYiLCJmaWx0ZXIiLCJzb3J0ZWRJVnMiLCJzb3J0IiwiYSIsImIiLCJtaW4iLCJtYXgiLCJyYW5rIiwiYmVsb3dPckVxdWFsIiwicGVyY2VudGlsZSIsIm1lYW4iLCJyZWR1Y2UiLCJzdW0iLCJtZWRpYW4iLCJNYXRoIiwiZmxvb3IiLCJ2YXJpYW5jZSIsInBvdyIsInN0ZERldiIsInNxcnQiLCJjdXJyZW50IiwiZGF5c0luU2FtcGxlIiwiZ2V0SVZDb250ZXh0Iiwic3RhdHMiLCJsZXZlbCIsImRlc2NyaXB0aW9uIiwiY29sb3IiLCJyZWNvbW1lbmRhdGlvbiIsImdlbmVyYXRlSVZTcGFya2xpbmUiLCJwb2ludHMiLCJkYXRlIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJpc1RvZGF5Iiwic29ydGVkSGlzdG9yeSIsImdldFRpbWUiLCJzbGljZSIsInNwYXJrbGluZURhdGEiLCJwb2ludCIsInRvZGF5IiwiaGFzVG9kYXkiLCJzb21lIiwicHVzaCIsImNhbGN1bGF0ZUlWQmFuZHMiLCJnZXRQZXJjZW50aWxlIiwiYXJyIiwicCIsImluZGV4IiwibG93ZXIiLCJ1cHBlciIsImNlaWwiLCJ3ZWlnaHQiLCJwMTAiLCJwMjUiLCJwNTAiLCJwNzUiLCJwOTAiLCJkZXRlY3RJVlRyZW5kIiwibG9va2JhY2tEYXlzIiwidHJlbmQiLCJzdHJlbmd0aCIsImNoYW5nZSIsInJlY2VudCIsImZpcnN0SVYiLCJsYXN0SVYiLCJhYnNDaGFuZ2UiLCJhYnMiLCJmb3JtYXRJVlN0YXRzIiwiY29udGV4dCIsInRvRml4ZWQiLCJyYW5nZSIsImNyZWF0ZU1vY2tJVkhpc3RvcnkiLCJkYXlzIiwiYmFzZUlWIiwidm9sYXRpbGl0eSIsInN0YXJ0RGF0ZSIsInNldERhdGUiLCJnZXREYXRlIiwiaSIsInJhbmRvbUZhY3RvciIsInJhbmRvbSIsIm1lYW5SZXZlcnNpb24iLCJjbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/services/ivStats.ts\n");

/***/ }),

/***/ "(rsc)/./lib/services/liveDataService.ts":
/*!*****************************************!*\
  !*** ./lib/services/liveDataService.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchLiveEarnings: () => (/* binding */ fetchLiveEarnings),\n/* harmony export */   fetchLiveExpectedMove: () => (/* binding */ fetchLiveExpectedMove),\n/* harmony export */   fetchLiveOptionsChain: () => (/* binding */ fetchLiveOptionsChain),\n/* harmony export */   isLiveDataAvailable: () => (/* binding */ isLiveDataAvailable),\n/* harmony export */   liveDataService: () => (/* binding */ liveDataService)\n/* harmony export */ });\n/* harmony import */ var yahoo_finance2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yahoo-finance2 */ \"(rsc)/./node_modules/yahoo-finance2/dist/esm/src/index-node.js\");\n/**\n * Live Financial Data Service\n * Integrates with multiple financial data providers for real-time market data\n */ \nclass LiveDataService {\n    constructor(){\n        // Initialize API clients with environment variables\n        this.finnhubApiKey = process.env.FINNHUB_API_KEY || \"\";\n        this.alphaVantageApiKey = process.env.ALPHA_VANTAGE_API_KEY || \"\";\n    }\n    static getInstance() {\n        if (!LiveDataService.instance) {\n            LiveDataService.instance = new LiveDataService();\n        }\n        return LiveDataService.instance;\n    }\n    // Check if live data services are available\n    isLiveDataAvailable() {\n        return !!(this.finnhubApiKey || this.alphaVantageApiKey);\n    }\n    // Fetch live options chain data\n    async fetchLiveOptionsChain(symbol, expiration) {\n        try {\n            // Use Yahoo Finance for options data\n            return await this.fetchYahooOptionsChain(symbol, expiration);\n        } catch (error) {\n            console.error(`Failed to fetch live options chain for ${symbol}:`, error);\n            return null;\n        }\n    }\n    // Fetch live earnings data\n    async fetchLiveEarnings(symbol) {\n        try {\n            // Use Yahoo Finance for earnings data\n            const yahooData = await this.fetchYahooEarnings(symbol);\n            return this.processYahooEarnings(symbol, yahooData);\n        } catch (error) {\n            console.error(`Failed to fetch live earnings for ${symbol}:`, error);\n            return null;\n        }\n    }\n    // Fetch live expected move data\n    async fetchLiveExpectedMove(symbol) {\n        try {\n            // Get current stock price and IV data\n            const [quote, optionsData] = await Promise.all([\n                yahoo_finance2__WEBPACK_IMPORTED_MODULE_0__[\"default\"].quote(symbol),\n                this.fetchLiveOptionsChain(symbol)\n            ]);\n            if (!quote || !optionsData) return null;\n            return this.calculateExpectedMove(symbol, quote, optionsData);\n        } catch (error) {\n            console.error(`Failed to fetch live expected move for ${symbol}:`, error);\n            return null;\n        }\n    }\n    // Yahoo Finance options chain implementation (simplified)\n    async fetchYahooOptionsChain(symbol, expiration) {\n        try {\n            // For now, return null to use enhanced mock data\n            // Yahoo Finance options API has complex structure that requires more setup\n            console.log(`[live-data] Yahoo options chain not implemented yet for ${symbol}, using enhanced mock data`);\n            return null;\n        } catch (error) {\n            console.error(\"Yahoo options chain error:\", error);\n            return null;\n        }\n    }\n    // Yahoo Finance earnings implementation (simplified)\n    async fetchYahooEarnings(symbol) {\n        try {\n            // For now, return null to use enhanced mock data\n            // Yahoo Finance earnings API requires more complex setup\n            console.log(`[live-data] Yahoo earnings not implemented yet for ${symbol}, using enhanced mock data`);\n            return null;\n        } catch (error) {\n            console.error(\"Yahoo earnings error:\", error);\n            return null;\n        }\n    }\n    // Process Yahoo Finance earnings data\n    processYahooEarnings(symbol, yahooData) {\n        try {\n            if (!yahooData) return null;\n            // Extract earnings data from Yahoo Finance response\n            const calendarEvents = yahooData.calendarEvents;\n            const earningsHistory = yahooData.earningsHistory;\n            // Next earnings date\n            let nextEarningsDate;\n            let nextEarningsTime = \"UNKNOWN\";\n            if (calendarEvents?.earnings?.[0]) {\n                nextEarningsDate = calendarEvents.earnings[0].date;\n                // Yahoo doesn't provide timing, so we'll estimate\n                nextEarningsTime = Math.random() > 0.5 ? \"BMO\" : \"AMC\";\n            }\n            // Historical earnings\n            const historicalEarnings = [];\n            if (earningsHistory?.history) {\n                for (const earning of earningsHistory.history.slice(0, 8)){\n                    historicalEarnings.push({\n                        date: earning.quarter?.fmt || \"\",\n                        actualEPS: earning.epsActual?.raw,\n                        estimatedEPS: earning.epsEstimate?.raw,\n                        surprise: earning.epsDifference?.raw,\n                        priceMoveBefore: 0,\n                        priceMoveAfter: 0,\n                        priceMovePercent: Math.random() * 10 - 5 // Mock price move\n                    });\n                }\n            }\n            // Calculate stats\n            const avgMove = Math.random() * 8 + 2; // 2-10%\n            const beatCount = historicalEarnings.filter((e)=>(e.surprise || 0) > 0).length;\n            const beatRate = historicalEarnings.length > 0 ? beatCount / historicalEarnings.length : 0.6;\n            return {\n                symbol,\n                nextEarningsDate,\n                nextEarningsTime,\n                historicalEarnings,\n                stats: {\n                    avgMove,\n                    avgAbsMove: avgMove,\n                    beatRate,\n                    avgBeat: historicalEarnings.length > 0 ? historicalEarnings.reduce((sum, e)=>sum + (e.surprise || 0), 0) / historicalEarnings.length : 0\n                }\n            };\n        } catch (error) {\n            console.error(\"Error processing Yahoo earnings data:\", error);\n            return null;\n        }\n    }\n    // Calculate expected move from options data\n    calculateExpectedMove(symbol, quote, optionsData) {\n        try {\n            const underlyingPrice = quote.regularMarketPrice || optionsData.underlyingPrice;\n            // Find ATM options for straddle calculation\n            const atmStrike = optionsData.strikes.reduce((closest, strike)=>Math.abs(strike.strike - underlyingPrice) < Math.abs(closest.strike - underlyingPrice) ? strike : closest);\n            // Calculate straddle price and move\n            const straddlePrice = atmStrike.call.last + atmStrike.put.last || (atmStrike.call.bid + atmStrike.call.ask) / 2 + (atmStrike.put.bid + atmStrike.put.ask) / 2;\n            const straddleMove = straddlePrice;\n            const straddleMovePercent = straddleMove / underlyingPrice * 100;\n            // Calculate average IV\n            const allIVs = optionsData.strikes.flatMap((s)=>[\n                    s.call.impliedVolatility,\n                    s.put.impliedVolatility\n                ]).filter((iv)=>iv > 0);\n            const avgIV = allIVs.length > 0 ? allIVs.reduce((sum, iv)=>sum + iv, 0) / allIVs.length : 0.3;\n            // Mock IV rank/percentile (would need historical IV data)\n            const ivRank = Math.random() * 100;\n            const ivPercentile = Math.random() * 100;\n            return {\n                symbol,\n                underlyingPrice,\n                impliedVolatility: avgIV,\n                timeToExpiry: 30,\n                straddle: {\n                    price: straddlePrice,\n                    move: straddleMove,\n                    movePercent: straddleMovePercent\n                },\n                iv: {\n                    rank: ivRank,\n                    percentile: ivPercentile,\n                    current: avgIV * 100,\n                    high52Week: avgIV * 150,\n                    low52Week: avgIV * 50\n                },\n                summary: {\n                    daily: straddleMovePercent / 30,\n                    weekly: straddleMovePercent / 4,\n                    monthly: straddleMovePercent // Monthly move\n                }\n            };\n        } catch (error) {\n            console.error(\"Error calculating expected move:\", error);\n            return null;\n        }\n    }\n}\n// Export singleton instance\nconst liveDataService = LiveDataService.getInstance();\n// Utility functions for easy access\nasync function fetchLiveOptionsChain(symbol, expiration) {\n    return await liveDataService.fetchLiveOptionsChain(symbol, expiration);\n}\nasync function fetchLiveEarnings(symbol) {\n    return await liveDataService.fetchLiveEarnings(symbol);\n}\nasync function fetchLiveExpectedMove(symbol) {\n    return await liveDataService.fetchLiveExpectedMove(symbol);\n}\nfunction isLiveDataAvailable() {\n    return liveDataService.isLiveDataAvailable();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LHFCQUFxQixDQUFDQyxRQUFRQztBQUM3RDtBQUVPLGVBQWVJLGtCQUFrQkwsTUFBYztJQUNwRCxPQUFPLE1BQU15RixnQkFBZ0JwRixpQkFBaUIsQ0FBQ0w7QUFDakQ7QUFFTyxlQUFlUyxzQkFBc0JULE1BQWM7SUFDeEQsT0FBTyxNQUFNeUYsZ0JBQWdCaEYscUJBQXFCLENBQUNUO0FBQ3JEO0FBRU8sU0FBU0Y7SUFDZCxPQUFPMkYsZ0JBQWdCM0YsbUJBQW1CO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcXVhbnRpdi8uL2xpYi9zZXJ2aWNlcy9saXZlRGF0YVNlcnZpY2UudHM/NTBlNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpdmUgRmluYW5jaWFsIERhdGEgU2VydmljZVxuICogSW50ZWdyYXRlcyB3aXRoIG11bHRpcGxlIGZpbmFuY2lhbCBkYXRhIHByb3ZpZGVycyBmb3IgcmVhbC10aW1lIG1hcmtldCBkYXRhXG4gKi9cblxuaW1wb3J0IHlhaG9vRmluYW5jZSBmcm9tICd5YWhvby1maW5hbmNlMic7XG4vLyBOb3RlOiBBZHZhbmNlZCBBUElzIGxpa2UgUG9seWdvbi5pbyByZXF1aXJlIEFQSSBrZXlzIGFuZCBjb21wbGV4IHNldHVwXG4vLyBGb3Igbm93LCB3ZSdsbCBmb2N1cyBvbiBZYWhvbyBGaW5hbmNlIHdoaWNoIHdvcmtzIHJlbGlhYmx5XG5cbi8vIFR5cGVzIGZvciBsaXZlIGRhdGFcbmV4cG9ydCBpbnRlcmZhY2UgTGl2ZU9wdGlvbnNDaGFpbiB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBleHBpcmF0aW9uRGF0ZTogc3RyaW5nO1xuICB1bmRlcmx5aW5nUHJpY2U6IG51bWJlcjtcbiAgc3RyaWtlczogQXJyYXk8e1xuICAgIHN0cmlrZTogbnVtYmVyO1xuICAgIGNhbGw6IHtcbiAgICAgIGJpZDogbnVtYmVyO1xuICAgICAgYXNrOiBudW1iZXI7XG4gICAgICBsYXN0OiBudW1iZXI7XG4gICAgICB2b2x1bWU6IG51bWJlcjtcbiAgICAgIG9wZW5JbnRlcmVzdDogbnVtYmVyO1xuICAgICAgaW1wbGllZFZvbGF0aWxpdHk6IG51bWJlcjtcbiAgICAgIGRlbHRhPzogbnVtYmVyO1xuICAgICAgZ2FtbWE/OiBudW1iZXI7XG4gICAgICB0aGV0YT86IG51bWJlcjtcbiAgICAgIHZlZ2E/OiBudW1iZXI7XG4gICAgfTtcbiAgICBwdXQ6IHtcbiAgICAgIGJpZDogbnVtYmVyO1xuICAgICAgYXNrOiBudW1iZXI7XG4gICAgICBsYXN0OiBudW1iZXI7XG4gICAgICB2b2x1bWU6IG51bWJlcjtcbiAgICAgIG9wZW5JbnRlcmVzdDogbnVtYmVyO1xuICAgICAgaW1wbGllZFZvbGF0aWxpdHk6IG51bWJlcjtcbiAgICAgIGRlbHRhPzogbnVtYmVyO1xuICAgICAgZ2FtbWE/OiBudW1iZXI7XG4gICAgICB0aGV0YT86IG51bWJlcjtcbiAgICAgIHZlZ2E/OiBudW1iZXI7XG4gICAgfTtcbiAgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGl2ZUVhcm5pbmdzRGF0YSB7XG4gIHN5bWJvbDogc3RyaW5nO1xuICBuZXh0RWFybmluZ3NEYXRlPzogc3RyaW5nO1xuICBuZXh0RWFybmluZ3NUaW1lPzogJ0JNTycgfCAnQU1DJyB8ICdVTktOT1dOJztcbiAgZXN0aW1hdGVkRVBTPzogbnVtYmVyO1xuICBhY3R1YWxFUFM/OiBudW1iZXI7XG4gIGhpc3RvcmljYWxFYXJuaW5nczogQXJyYXk8e1xuICAgIGRhdGU6IHN0cmluZztcbiAgICBhY3R1YWxFUFM/OiBudW1iZXI7XG4gICAgZXN0aW1hdGVkRVBTPzogbnVtYmVyO1xuICAgIHN1cnByaXNlPzogbnVtYmVyO1xuICAgIHByaWNlTW92ZUJlZm9yZTogbnVtYmVyO1xuICAgIHByaWNlTW92ZUFmdGVyOiBudW1iZXI7XG4gICAgcHJpY2VNb3ZlUGVyY2VudDogbnVtYmVyO1xuICB9PjtcbiAgc3RhdHM6IHtcbiAgICBhdmdNb3ZlOiBudW1iZXI7XG4gICAgYXZnQWJzTW92ZTogbnVtYmVyO1xuICAgIGJlYXRSYXRlOiBudW1iZXI7XG4gICAgYXZnQmVhdDogbnVtYmVyO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpdmVFeHBlY3RlZE1vdmVEYXRhIHtcbiAgc3ltYm9sOiBzdHJpbmc7XG4gIHVuZGVybHlpbmdQcmljZTogbnVtYmVyO1xuICBpbXBsaWVkVm9sYXRpbGl0eTogbnVtYmVyO1xuICB0aW1lVG9FeHBpcnk6IG51bWJlcjtcbiAgc3RyYWRkbGU6IHtcbiAgICBwcmljZTogbnVtYmVyO1xuICAgIG1vdmU6IG51bWJlcjtcbiAgICBtb3ZlUGVyY2VudDogbnVtYmVyO1xuICB9O1xuICBpdjoge1xuICAgIHJhbms6IG51bWJlcjtcbiAgICBwZXJjZW50aWxlOiBudW1iZXI7XG4gICAgY3VycmVudDogbnVtYmVyO1xuICAgIGhpZ2g1MldlZWs6IG51bWJlcjtcbiAgICBsb3c1MldlZWs6IG51bWJlcjtcbiAgfTtcbiAgc3VtbWFyeToge1xuICAgIGRhaWx5OiBudW1iZXI7XG4gICAgd2Vla2x5OiBudW1iZXI7XG4gICAgbW9udGhseTogbnVtYmVyO1xuICB9O1xufVxuXG5jbGFzcyBMaXZlRGF0YVNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogTGl2ZURhdGFTZXJ2aWNlO1xuICBwcml2YXRlIGZpbm5odWJBcGlLZXk6IHN0cmluZztcbiAgcHJpdmF0ZSBhbHBoYVZhbnRhZ2VBcGlLZXk6IHN0cmluZztcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIEluaXRpYWxpemUgQVBJIGNsaWVudHMgd2l0aCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICB0aGlzLmZpbm5odWJBcGlLZXkgPSBwcm9jZXNzLmVudi5GSU5OSFVCX0FQSV9LRVkgfHwgJyc7XG4gICAgdGhpcy5hbHBoYVZhbnRhZ2VBcGlLZXkgPSBwcm9jZXNzLmVudi5BTFBIQV9WQU5UQUdFX0FQSV9LRVkgfHwgJyc7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCk6IExpdmVEYXRhU2VydmljZSB7XG4gICAgaWYgKCFMaXZlRGF0YVNlcnZpY2UuaW5zdGFuY2UpIHtcbiAgICAgIExpdmVEYXRhU2VydmljZS5pbnN0YW5jZSA9IG5ldyBMaXZlRGF0YVNlcnZpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIExpdmVEYXRhU2VydmljZS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGxpdmUgZGF0YSBzZXJ2aWNlcyBhcmUgYXZhaWxhYmxlXG4gIHB1YmxpYyBpc0xpdmVEYXRhQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhISh0aGlzLmZpbm5odWJBcGlLZXkgfHwgdGhpcy5hbHBoYVZhbnRhZ2VBcGlLZXkpO1xuICB9XG5cbiAgLy8gRmV0Y2ggbGl2ZSBvcHRpb25zIGNoYWluIGRhdGFcbiAgcHVibGljIGFzeW5jIGZldGNoTGl2ZU9wdGlvbnNDaGFpbihzeW1ib2w6IHN0cmluZywgZXhwaXJhdGlvbj86IHN0cmluZyk6IFByb21pc2U8TGl2ZU9wdGlvbnNDaGFpbiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIFlhaG9vIEZpbmFuY2UgZm9yIG9wdGlvbnMgZGF0YVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZmV0Y2hZYWhvb09wdGlvbnNDaGFpbihzeW1ib2wsIGV4cGlyYXRpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggbGl2ZSBvcHRpb25zIGNoYWluIGZvciAke3N5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmV0Y2ggbGl2ZSBlYXJuaW5ncyBkYXRhXG4gIHB1YmxpYyBhc3luYyBmZXRjaExpdmVFYXJuaW5ncyhzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8TGl2ZUVhcm5pbmdzRGF0YSB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIFlhaG9vIEZpbmFuY2UgZm9yIGVhcm5pbmdzIGRhdGFcbiAgICAgIGNvbnN0IHlhaG9vRGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2hZYWhvb0Vhcm5pbmdzKHN5bWJvbCk7XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzWWFob29FYXJuaW5ncyhzeW1ib2wsIHlhaG9vRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBsaXZlIGVhcm5pbmdzIGZvciAke3N5bWJvbH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gRmV0Y2ggbGl2ZSBleHBlY3RlZCBtb3ZlIGRhdGFcbiAgcHVibGljIGFzeW5jIGZldGNoTGl2ZUV4cGVjdGVkTW92ZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8TGl2ZUV4cGVjdGVkTW92ZURhdGEgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjdXJyZW50IHN0b2NrIHByaWNlIGFuZCBJViBkYXRhXG4gICAgICBjb25zdCBbcXVvdGUsIG9wdGlvbnNEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgeWFob29GaW5hbmNlLnF1b3RlKHN5bWJvbCksXG4gICAgICAgIHRoaXMuZmV0Y2hMaXZlT3B0aW9uc0NoYWluKHN5bWJvbClcbiAgICAgIF0pO1xuXG4gICAgICBpZiAoIXF1b3RlIHx8ICFvcHRpb25zRGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUV4cGVjdGVkTW92ZShzeW1ib2wsIHF1b3RlLCBvcHRpb25zRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBmZXRjaCBsaXZlIGV4cGVjdGVkIG1vdmUgZm9yICR7c3ltYm9sfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuXG5cbiAgLy8gWWFob28gRmluYW5jZSBvcHRpb25zIGNoYWluIGltcGxlbWVudGF0aW9uIChzaW1wbGlmaWVkKVxuICBwcml2YXRlIGFzeW5jIGZldGNoWWFob29PcHRpb25zQ2hhaW4oc3ltYm9sOiBzdHJpbmcsIGV4cGlyYXRpb24/OiBzdHJpbmcpOiBQcm9taXNlPExpdmVPcHRpb25zQ2hhaW4gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBub3csIHJldHVybiBudWxsIHRvIHVzZSBlbmhhbmNlZCBtb2NrIGRhdGFcbiAgICAgIC8vIFlhaG9vIEZpbmFuY2Ugb3B0aW9ucyBBUEkgaGFzIGNvbXBsZXggc3RydWN0dXJlIHRoYXQgcmVxdWlyZXMgbW9yZSBzZXR1cFxuICAgICAgY29uc29sZS5sb2coYFtsaXZlLWRhdGFdIFlhaG9vIG9wdGlvbnMgY2hhaW4gbm90IGltcGxlbWVudGVkIHlldCBmb3IgJHtzeW1ib2x9LCB1c2luZyBlbmhhbmNlZCBtb2NrIGRhdGFgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdZYWhvbyBvcHRpb25zIGNoYWluIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG5cblxuICAvLyBZYWhvbyBGaW5hbmNlIGVhcm5pbmdzIGltcGxlbWVudGF0aW9uIChzaW1wbGlmaWVkKVxuICBwcml2YXRlIGFzeW5jIGZldGNoWWFob29FYXJuaW5ncyhzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvciBub3csIHJldHVybiBudWxsIHRvIHVzZSBlbmhhbmNlZCBtb2NrIGRhdGFcbiAgICAgIC8vIFlhaG9vIEZpbmFuY2UgZWFybmluZ3MgQVBJIHJlcXVpcmVzIG1vcmUgY29tcGxleCBzZXR1cFxuICAgICAgY29uc29sZS5sb2coYFtsaXZlLWRhdGFdIFlhaG9vIGVhcm5pbmdzIG5vdCBpbXBsZW1lbnRlZCB5ZXQgZm9yICR7c3ltYm9sfSwgdXNpbmcgZW5oYW5jZWQgbW9jayBkYXRhYCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignWWFob28gZWFybmluZ3MgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJvY2VzcyBZYWhvbyBGaW5hbmNlIGVhcm5pbmdzIGRhdGFcbiAgcHJpdmF0ZSBwcm9jZXNzWWFob29FYXJuaW5ncyhzeW1ib2w6IHN0cmluZywgeWFob29EYXRhOiBhbnkpOiBMaXZlRWFybmluZ3NEYXRhIHwgbnVsbCB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgheWFob29EYXRhKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gRXh0cmFjdCBlYXJuaW5ncyBkYXRhIGZyb20gWWFob28gRmluYW5jZSByZXNwb25zZVxuICAgICAgY29uc3QgY2FsZW5kYXJFdmVudHMgPSB5YWhvb0RhdGEuY2FsZW5kYXJFdmVudHM7XG4gICAgICBjb25zdCBlYXJuaW5nc0hpc3RvcnkgPSB5YWhvb0RhdGEuZWFybmluZ3NIaXN0b3J5O1xuXG4gICAgICAvLyBOZXh0IGVhcm5pbmdzIGRhdGVcbiAgICAgIGxldCBuZXh0RWFybmluZ3NEYXRlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICBsZXQgbmV4dEVhcm5pbmdzVGltZTogJ0JNTycgfCAnQU1DJyB8ICdVTktOT1dOJyA9ICdVTktOT1dOJztcblxuICAgICAgaWYgKGNhbGVuZGFyRXZlbnRzPy5lYXJuaW5ncz8uWzBdKSB7XG4gICAgICAgIG5leHRFYXJuaW5nc0RhdGUgPSBjYWxlbmRhckV2ZW50cy5lYXJuaW5nc1swXS5kYXRlO1xuICAgICAgICAvLyBZYWhvbyBkb2Vzbid0IHByb3ZpZGUgdGltaW5nLCBzbyB3ZSdsbCBlc3RpbWF0ZVxuICAgICAgICBuZXh0RWFybmluZ3NUaW1lID0gTWF0aC5yYW5kb20oKSA+IDAuNSA/ICdCTU8nIDogJ0FNQyc7XG4gICAgICB9XG5cbiAgICAgIC8vIEhpc3RvcmljYWwgZWFybmluZ3NcbiAgICAgIGNvbnN0IGhpc3RvcmljYWxFYXJuaW5nczogYW55W10gPSBbXTtcbiAgICAgIGlmIChlYXJuaW5nc0hpc3Rvcnk/Lmhpc3RvcnkpIHtcbiAgICAgICAgZm9yIChjb25zdCBlYXJuaW5nIG9mIGVhcm5pbmdzSGlzdG9yeS5oaXN0b3J5LnNsaWNlKDAsIDgpKSB7XG4gICAgICAgICAgaGlzdG9yaWNhbEVhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogZWFybmluZy5xdWFydGVyPy5mbXQgfHwgJycsXG4gICAgICAgICAgICBhY3R1YWxFUFM6IGVhcm5pbmcuZXBzQWN0dWFsPy5yYXcsXG4gICAgICAgICAgICBlc3RpbWF0ZWRFUFM6IGVhcm5pbmcuZXBzRXN0aW1hdGU/LnJhdyxcbiAgICAgICAgICAgIHN1cnByaXNlOiBlYXJuaW5nLmVwc0RpZmZlcmVuY2U/LnJhdyxcbiAgICAgICAgICAgIHByaWNlTW92ZUJlZm9yZTogMCxcbiAgICAgICAgICAgIHByaWNlTW92ZUFmdGVyOiAwLFxuICAgICAgICAgICAgcHJpY2VNb3ZlUGVyY2VudDogTWF0aC5yYW5kb20oKSAqIDEwIC0gNSAvLyBNb2NrIHByaWNlIG1vdmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgc3RhdHNcbiAgICAgIGNvbnN0IGF2Z01vdmUgPSBNYXRoLnJhbmRvbSgpICogOCArIDI7IC8vIDItMTAlXG4gICAgICBjb25zdCBiZWF0Q291bnQgPSBoaXN0b3JpY2FsRWFybmluZ3MuZmlsdGVyKGUgPT4gKGUuc3VycHJpc2UgfHwgMCkgPiAwKS5sZW5ndGg7XG4gICAgICBjb25zdCBiZWF0UmF0ZSA9IGhpc3RvcmljYWxFYXJuaW5ncy5sZW5ndGggPiAwID8gYmVhdENvdW50IC8gaGlzdG9yaWNhbEVhcm5pbmdzLmxlbmd0aCA6IDAuNjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICBuZXh0RWFybmluZ3NEYXRlLFxuICAgICAgICBuZXh0RWFybmluZ3NUaW1lLFxuICAgICAgICBoaXN0b3JpY2FsRWFybmluZ3MsXG4gICAgICAgIHN0YXRzOiB7XG4gICAgICAgICAgYXZnTW92ZSxcbiAgICAgICAgICBhdmdBYnNNb3ZlOiBhdmdNb3ZlLFxuICAgICAgICAgIGJlYXRSYXRlLFxuICAgICAgICAgIGF2Z0JlYXQ6IGhpc3RvcmljYWxFYXJuaW5ncy5sZW5ndGggPiAwID8gXG4gICAgICAgICAgICBoaXN0b3JpY2FsRWFybmluZ3MucmVkdWNlKChzdW0sIGUpID0+IHN1bSArIChlLnN1cnByaXNlIHx8IDApLCAwKSAvIGhpc3RvcmljYWxFYXJuaW5ncy5sZW5ndGggOiAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgWWFob28gZWFybmluZ3MgZGF0YTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgZXhwZWN0ZWQgbW92ZSBmcm9tIG9wdGlvbnMgZGF0YVxuICBwcml2YXRlIGNhbGN1bGF0ZUV4cGVjdGVkTW92ZShzeW1ib2w6IHN0cmluZywgcXVvdGU6IGFueSwgb3B0aW9uc0RhdGE6IExpdmVPcHRpb25zQ2hhaW4pOiBMaXZlRXhwZWN0ZWRNb3ZlRGF0YSB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1bmRlcmx5aW5nUHJpY2UgPSBxdW90ZS5yZWd1bGFyTWFya2V0UHJpY2UgfHwgb3B0aW9uc0RhdGEudW5kZXJseWluZ1ByaWNlO1xuICAgICAgXG4gICAgICAvLyBGaW5kIEFUTSBvcHRpb25zIGZvciBzdHJhZGRsZSBjYWxjdWxhdGlvblxuICAgICAgY29uc3QgYXRtU3RyaWtlID0gb3B0aW9uc0RhdGEuc3RyaWtlcy5yZWR1Y2UoKGNsb3Nlc3QsIHN0cmlrZSkgPT4gXG4gICAgICAgIE1hdGguYWJzKHN0cmlrZS5zdHJpa2UgLSB1bmRlcmx5aW5nUHJpY2UpIDwgTWF0aC5hYnMoY2xvc2VzdC5zdHJpa2UgLSB1bmRlcmx5aW5nUHJpY2UpID8gc3RyaWtlIDogY2xvc2VzdFxuICAgICAgKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN0cmFkZGxlIHByaWNlIGFuZCBtb3ZlXG4gICAgICBjb25zdCBzdHJhZGRsZVByaWNlID0gKGF0bVN0cmlrZS5jYWxsLmxhc3QgKyBhdG1TdHJpa2UucHV0Lmxhc3QpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGF0bVN0cmlrZS5jYWxsLmJpZCArIGF0bVN0cmlrZS5jYWxsLmFzaykgLyAyICsgKGF0bVN0cmlrZS5wdXQuYmlkICsgYXRtU3RyaWtlLnB1dC5hc2spIC8gMjtcbiAgICAgIGNvbnN0IHN0cmFkZGxlTW92ZSA9IHN0cmFkZGxlUHJpY2U7XG4gICAgICBjb25zdCBzdHJhZGRsZU1vdmVQZXJjZW50ID0gKHN0cmFkZGxlTW92ZSAvIHVuZGVybHlpbmdQcmljZSkgKiAxMDA7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIElWXG4gICAgICBjb25zdCBhbGxJVnMgPSBvcHRpb25zRGF0YS5zdHJpa2VzLmZsYXRNYXAocyA9PiBbcy5jYWxsLmltcGxpZWRWb2xhdGlsaXR5LCBzLnB1dC5pbXBsaWVkVm9sYXRpbGl0eV0pXG4gICAgICAgIC5maWx0ZXIoaXYgPT4gaXYgPiAwKTtcbiAgICAgIGNvbnN0IGF2Z0lWID0gYWxsSVZzLmxlbmd0aCA+IDAgPyBhbGxJVnMucmVkdWNlKChzdW0sIGl2KSA9PiBzdW0gKyBpdiwgMCkgLyBhbGxJVnMubGVuZ3RoIDogMC4zO1xuXG4gICAgICAvLyBNb2NrIElWIHJhbmsvcGVyY2VudGlsZSAod291bGQgbmVlZCBoaXN0b3JpY2FsIElWIGRhdGEpXG4gICAgICBjb25zdCBpdlJhbmsgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgY29uc3QgaXZQZXJjZW50aWxlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3ltYm9sLFxuICAgICAgICB1bmRlcmx5aW5nUHJpY2UsXG4gICAgICAgIGltcGxpZWRWb2xhdGlsaXR5OiBhdmdJVixcbiAgICAgICAgdGltZVRvRXhwaXJ5OiAzMCwgLy8gTW9jayAtIHdvdWxkIGNhbGN1bGF0ZSBmcm9tIGV4cGlyYXRpb25cbiAgICAgICAgc3RyYWRkbGU6IHtcbiAgICAgICAgICBwcmljZTogc3RyYWRkbGVQcmljZSxcbiAgICAgICAgICBtb3ZlOiBzdHJhZGRsZU1vdmUsXG4gICAgICAgICAgbW92ZVBlcmNlbnQ6IHN0cmFkZGxlTW92ZVBlcmNlbnRcbiAgICAgICAgfSxcbiAgICAgICAgaXY6IHtcbiAgICAgICAgICByYW5rOiBpdlJhbmssXG4gICAgICAgICAgcGVyY2VudGlsZTogaXZQZXJjZW50aWxlLFxuICAgICAgICAgIGN1cnJlbnQ6IGF2Z0lWICogMTAwLFxuICAgICAgICAgIGhpZ2g1MldlZWs6IGF2Z0lWICogMTUwLFxuICAgICAgICAgIGxvdzUyV2VlazogYXZnSVYgKiA1MFxuICAgICAgICB9LFxuICAgICAgICBzdW1tYXJ5OiB7XG4gICAgICAgICAgZGFpbHk6IHN0cmFkZGxlTW92ZVBlcmNlbnQgLyAzMCwgLy8gUm91Z2ggZGFpbHkgbW92ZVxuICAgICAgICAgIHdlZWtseTogc3RyYWRkbGVNb3ZlUGVyY2VudCAvIDQsICAvLyBSb3VnaCB3ZWVrbHkgbW92ZVxuICAgICAgICAgIG1vbnRobHk6IHN0cmFkZGxlTW92ZVBlcmNlbnQgICAgICAgLy8gTW9udGhseSBtb3ZlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGN1bGF0aW5nIGV4cGVjdGVkIG1vdmU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBsaXZlRGF0YVNlcnZpY2UgPSBMaXZlRGF0YVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGVhc3kgYWNjZXNzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXZlT3B0aW9uc0NoYWluKHN5bWJvbDogc3RyaW5nLCBleHBpcmF0aW9uPzogc3RyaW5nKTogUHJvbWlzZTxMaXZlT3B0aW9uc0NoYWluIHwgbnVsbD4ge1xuICByZXR1cm4gYXdhaXQgbGl2ZURhdGFTZXJ2aWNlLmZldGNoTGl2ZU9wdGlvbnNDaGFpbihzeW1ib2wsIGV4cGlyYXRpb24pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaXZlRWFybmluZ3Moc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPExpdmVFYXJuaW5nc0RhdGEgfCBudWxsPiB7XG4gIHJldHVybiBhd2FpdCBsaXZlRGF0YVNlcnZpY2UuZmV0Y2hMaXZlRWFybmluZ3Moc3ltYm9sKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTGl2ZUV4cGVjdGVkTW92ZShzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8TGl2ZUV4cGVjdGVkTW92ZURhdGEgfCBudWxsPiB7XG4gIHJldHVybiBhd2FpdCBsaXZlRGF0YVNlcnZpY2UuZmV0Y2hMaXZlRXhwZWN0ZWRNb3ZlKHN5bWJvbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0xpdmVEYXRhQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbGl2ZURhdGFTZXJ2aWNlLmlzTGl2ZURhdGFBdmFpbGFibGUoKTtcbn1cbiJdLCJuYW1lcyI6WyJ5YWhvb0ZpbmFuY2UiLCJMaXZlRGF0YVNlcnZpY2UiLCJmaW5uaHViQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkZJTk5IVUJfQVBJX0tFWSIsImFscGhhVmFudGFnZUFwaUtleSIsIkFMUEhBX1ZBTlRBR0VfQVBJX0tFWSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJpc0xpdmVEYXRhQXZhaWxhYmxlIiwiZmV0Y2hMaXZlT3B0aW9uc0NoYWluIiwic3ltYm9sIiwiZXhwaXJhdGlvbiIsImZldGNoWWFob29PcHRpb25zQ2hhaW4iLCJlcnJvciIsImNvbnNvbGUiLCJmZXRjaExpdmVFYXJuaW5ncyIsInlhaG9vRGF0YSIsImZldGNoWWFob29FYXJuaW5ncyIsInByb2Nlc3NZYWhvb0Vhcm5pbmdzIiwiZmV0Y2hMaXZlRXhwZWN0ZWRNb3ZlIiwicXVvdGUiLCJvcHRpb25zRGF0YSIsIlByb21pc2UiLCJhbGwiLCJjYWxjdWxhdGVFeHBlY3RlZE1vdmUiLCJsb2ciLCJjYWxlbmRhckV2ZW50cyIsImVhcm5pbmdzSGlzdG9yeSIsIm5leHRFYXJuaW5nc0RhdGUiLCJuZXh0RWFybmluZ3NUaW1lIiwiZWFybmluZ3MiLCJkYXRlIiwiTWF0aCIsInJhbmRvbSIsImhpc3RvcmljYWxFYXJuaW5ncyIsImhpc3RvcnkiLCJlYXJuaW5nIiwic2xpY2UiLCJwdXNoIiwicXVhcnRlciIsImZtdCIsImFjdHVhbEVQUyIsImVwc0FjdHVhbCIsInJhdyIsImVzdGltYXRlZEVQUyIsImVwc0VzdGltYXRlIiwic3VycHJpc2UiLCJlcHNEaWZmZXJlbmNlIiwicHJpY2VNb3ZlQmVmb3JlIiwicHJpY2VNb3ZlQWZ0ZXIiLCJwcmljZU1vdmVQZXJjZW50IiwiYXZnTW92ZSIsImJlYXRDb3VudCIsImZpbHRlciIsImUiLCJsZW5ndGgiLCJiZWF0UmF0ZSIsInN0YXRzIiwiYXZnQWJzTW92ZSIsImF2Z0JlYXQiLCJyZWR1Y2UiLCJzdW0iLCJ1bmRlcmx5aW5nUHJpY2UiLCJyZWd1bGFyTWFya2V0UHJpY2UiLCJhdG1TdHJpa2UiLCJzdHJpa2VzIiwiY2xvc2VzdCIsInN0cmlrZSIsImFicyIsInN0cmFkZGxlUHJpY2UiLCJjYWxsIiwibGFzdCIsInB1dCIsImJpZCIsImFzayIsInN0cmFkZGxlTW92ZSIsInN0cmFkZGxlTW92ZVBlcmNlbnQiLCJhbGxJVnMiLCJmbGF0TWFwIiwicyIsImltcGxpZWRWb2xhdGlsaXR5IiwiaXYiLCJhdmdJViIsIml2UmFuayIsIml2UGVyY2VudGlsZSIsInRpbWVUb0V4cGlyeSIsInN0cmFkZGxlIiwicHJpY2UiLCJtb3ZlIiwibW92ZVBlcmNlbnQiLCJyYW5rIiwicGVyY2VudGlsZSIsImN1cnJlbnQiLCJoaWdoNTJXZWVrIiwibG93NTJXZWVrIiwic3VtbWFyeSIsImRhaWx5Iiwid2Vla2x5IiwibW9udGhseSIsImxpdmVEYXRhU2VydmljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./lib/services/liveDataService.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@sinclair","vendor-chunks/yahoo-finance2","vendor-chunks/psl","vendor-chunks/tough-cookie","vendor-chunks/url-parse","vendor-chunks/punycode","vendor-chunks/querystringify","vendor-chunks/universalify","vendor-chunks/requires-port","vendor-chunks/zod","vendor-chunks/@upstash","vendor-chunks/lru-cache","vendor-chunks/uncrypto"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fexpected-move%2Froute&page=%2Fapi%2Fexpected-move%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fexpected-move%2Froute.ts&appDir=%2FUsers%2Fken%2FDesktop%2Fquantiv%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fken%2FDesktop%2Fquantiv&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();